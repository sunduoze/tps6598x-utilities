
import os
import sys

# The simplified definitions use many forced settings
# setting hide_simplified to true will also hide them from the user
hide_simplified = True

appcust_path = os.path.abspath(os.path.join('..', 'src'))
sys.path.append(appcust_path)
template_path = "templates"
sys.path.append(template_path)

import register_class
import function_class
import helper_functions

class cPDOCurrentField(register_class.cScalingDMTerminator) :
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'' : 0.01, 'A' : 0.01, 'mA' : 10.0}
        self.defaultUnit = 'A'


class cPDOVoltageField(register_class.cScalingDMTerminator) :
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'' : 0.05, 'V' : 0.05, 'mV' : 50.0}
        self.defaultUnit = 'V'

class cPDOPowerField(register_class.cScalingDMTerminator) :
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'' : 0.25, 'W' : 0.25, 'mW' : 250.0}
        self.defaultUnit = 'W'

class cOVPVoltageField(register_class.cScalingDMTerminator) :
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'' : 0.32, 'V' : 0.32, 'mV' : 320.0}
        self.defaultUnit = 'V'
        self.scalingOffset = 12

class cI2CTimeoutField(register_class.cScalingDMTerminator) :
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'' : 25.0, 'mS' : 25.0, 'S' : 0.025}
        self.defaultUnit = 'mS'
        self.scalingOffset = 1


class cDMFixedSourcePdoArray(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        self.addChild(cPDOCurrentField( self.register,  { 'name' : 'Maximum Current',
                                                                'offset' : 0,
                                                                'bit length' : 10}))

        self.addChild(cPDOVoltageField( self.register,  { 'name' : 'Voltage',
                                                                'offset' : 10,
                                                                'bit length' : 10}))

        PeakCurrent = register_class.cListDMTerminator( self.register,  { 'name' : 'Peak Current',
                                                                'offset' : 20,
                                                                'bit length' : 2})
        PeakCurrent.help = """Set the percentage that the Source current can peak over the max before an OCP event occurs."""
        PeakCurrent.setReportList(['100%', '130%', '150%', '200%'])

        self.addChild(PeakCurrent)
        
        reserved = register_class.cForceSetDMTerminator( self.register,  { 'name' : "reserved",
                                                        'offset' : 22,
                                                        'bit length' : 8,
                                                        'force value' : int(0),
                                                        'force display' : 'reserved, set 0'})

        reserved.setFromInt(0)
        reserved.hide()
        self.addChild(reserved)

        supplyType = register_class.cListDMTerminator( self.register,  { 'name' : 'Supply Type',
                                                                'offset' : 30,
                                                                'bit length' : 2})
        supplyType.help = """Select what type of supply will source this PDO."""
        supplyType.setReportList(['Fixed Source', 'Battery Source', 'Variable Source'])
        supplyType.addUpdateRegisterByName("self")
        supplyType.setMaxValue(2)

        self.addChild(supplyType)


class cDMFixedSinkPdoArray(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        self.addChild(cPDOCurrentField( self.register,  { 'name' : 'Operating Current',
                                                                'offset' : 0,
                                                                'bit length' : 10}))

        self.addChild(cPDOVoltageField( self.register,  { 'name' : 'Voltage',
                                                                'offset' : 10,
                                                                'bit length' : 10}))

        PeakCurrent = register_class.cListDMTerminator( self.register,  { 'name' : 'Peak Current',
                                                                'offset' : 20,
                                                                'bit length' : 2})
        PeakCurrent.help = """Set the percentage that the Sink current can peak over the max before an OCP event occurs."""
        PeakCurrent.setReportList(['100%', '130%', '150%', '200%'])

        self.addChild(PeakCurrent)

        reserved = register_class.cForceSetDMTerminator( self.register,  { 'name' : "reserved",
                                                        'offset' : 22,
                                                        'bit length' : 8,
                                                        'force value' : int(0),
                                                        'force display' : 'reserved, set 0'})

        reserved.setFromInt(0)
        reserved.hide()
        self.addChild(reserved)

        supplyType = register_class.cListDMTerminator( self.register,  { 'name' : 'Supply Type',
                                                                'offset' : 30,
                                                                'bit length' : 2})
        supplyType.help = """Select what type of supply will be attached to this Sink PDO."""
        supplyType.setReportList(['Fixed Sink', 'Battery Sink', 'Variable Sink'])
        supplyType.addUpdateRegisterByName("self")
        supplyType.setMaxValue(2)

        self.addChild(supplyType)

        if ('No RDO Extensions' in iDict) and (iDict['No RDO Extensions'] == True) :
            pass
        else :
            self.addChild(cPDOCurrentField( self.register,  { 'name' : 'Maximum Operating Current',
                                                                    'offset' : 224,
                                                                    'bit length' : 10}))

            self.addChild(cPDOCurrentField( self.register,  { 'name' : 'Minimum Operating Current',
                                                                    'offset' : 234,
                                                                    'bit length' : 10}))

            self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Ask For Max',
                                                                    'offset' : 254,
                                                                    'bit length' : 1}))



class cDMSourcePdo1Array(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        if ('Is Receive' in iDict) and (iDict['Is Receive'] == True) :
            isReceive = True
        else :
            isReceive = False

        self.addChild(cPDOCurrentField( self.register,  { 'name' : 'Maximum Current',
                                                                'offset' : 0,
                                                                'bit length' : 10}))

        fvDisplayWidget = cPDOVoltageField( self.register,  { 'name' : 'Voltage',
                                                                'offset' : 10,
                                                                'bit length' : 10})


        fixedVoltage = register_class.cForceSetDMTerminator( self.register,  { 'name' : 'Voltage',
                                                                'offset' : 10,
                                                                'bit length' : 10,
                                                                'force value' : int(100),
                                                                'force display' : '5 V',
                                                                'display widget' : fvDisplayWidget })

        fixedVoltage.help = """Source PDO1 voltage will always be set to 5V to follow PD Spec."""
        self.addChild(fixedVoltage)
        fixedVoltage.setFromInt(100)

        PeakCurrent = register_class.cListDMTerminator( self.register,  { 'name' : 'Peak Current',
                                                                'offset' : 20,
                                                                'bit length' : 2})

        PeakCurrent.setReportList(['100%', '130%', '150%', '200%'])
        PeakCurrent.help = """Set the percentage that the Source current can peak over the max before an OCP event occurs."""
        self.addChild(PeakCurrent)


        reserved = register_class.cForceSetDMTerminator( self.register,  { 'name' : "reserved",
                                                        'offset' : 22,
                                                        'bit length' : 3,
                                                        'force value' : int(0),
                                                        'force display' : 'reserved, set 0'})

        reserved.setFromInt(0)
        reserved.hide()
        self.addChild(reserved)

        # Dual Role and Externally Powered are overwritten by firmware, so avoid confusion by not listing in GUI


        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'USB Capable',
                                                                'offset' : 26,
                                                                'bit length' : 1}))


        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'USB Suspend Supported',
                                                                'offset' : 28,
                                                                'bit length' : 1}))

        if ('Is Receive' in iDict ) and (iDict['Is Receive'] == True ) :
            self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Dual Role Data',
                                                                    'offset' : 25,
                                                                    'bit length' : 1}))

            self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Externally Powered',
                                                                    'offset' : 27,
                                                                    'bit length' : 1}))

            self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Dual Role Power',
                                                                    'offset' : 29,
                                                                    'bit length' : 1}))


        supplyType = register_class.cListDMTerminator( self.register,  { 'name' : 'Supply Type',
                                                                'offset' : 30,
                                                                'bit length' : 2})
        supplyType.help = """Select what type of supply will source this PDO."""
        supplyType.setReportList(['Fixed Source', 'Battery Source', 'Variable Source'])
        supplyType.addUpdateRegisterByName("self")
        supplyType.setMaxValue(2)

        fixedSupplyType = register_class.cForceSetDMTerminator( self.register,  { 'name' : 'Supply Type',
                                                                'offset' : 30,
                                                                'bit length' : 2,
                                                                'force value' : int(0),
                                                                'force display' : 'Fixed Source',
                                                                'display widget' : supplyType })

        fixedSupplyType.help = """Supply Type for PDO0 may be Fixed, Battery, or Voltage and is compliant with the USB-PD specification."""
        self.addChild(fixedSupplyType)
        fixedSupplyType.setFromInt(0)


    def maxPower(self) :
        # 10 mA steps
        current = self.getChildByName('Maximum Current').valueToInt()
        # 50 mV steps
        voltage = self.getChildByName('Voltage').valueToInt()
        # 0.01 * 0.05 = .0005 Watts
        power = current * voltage * 0.0005

        return power

class cDMSinkPdo1Array(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        if ('Is Receive' in iDict) and (iDict['Is Receive'] == True) :
            isReceive = True
        else :
            isReceive = False

        self.addChild(cPDOCurrentField( self.register,  { 'name' : 'Operating Current',
                                                                'offset' : 0,
                                                                'bit length' : 10}))

        fvDisplayWidget = cPDOVoltageField( self.register,  { 'name' : 'Voltage',
                                                                'offset' : 10,
                                                                'bit length' : 10})


        fixedVoltage = register_class.cForceSetDMTerminator( self.register,  { 'name' : 'Voltage',
                                                                'offset' : 10,
                                                                'bit length' : 10,
                                                                'force value' : int(100),
                                                                'force display' : '5 V',
                                                                'display widget' : fvDisplayWidget })

        fixedVoltage.help = """Sink PDO1 will always be 5V to be PD Spec compliant."""
        self.addChild(fixedVoltage)
        fixedVoltage.setFromInt(100)

        PeakCurrent = register_class.cListDMTerminator( self.register,  { 'name' : 'Peak Current',
                                                                'offset' : 20,
                                                                'bit length' : 2})
        PeakCurrent.help = """Set the percentage that the Sink current can peak over the max before an OCP event occurs."""
        PeakCurrent.setReportList(['100%', '130%', '150%', '200%'])

        self.addChild(PeakCurrent)

        reserved = register_class.cForceSetDMTerminator( self.register,  { 'name' : "reserved",
                                                        'offset' : 22,
                                                        'bit length' : 3,
                                                        'force value' : int(0),
                                                        'force display' : 'reserved, set 0'})

        reserved.setFromInt(0)
        reserved.hide()
        self.addChild(reserved)

        # Dual Role and Externally Powered are overwritten by firmware, so avoid confusion by not listing in GUI
        # USB capable is set in autonegotiate sink register
        # Higher Capability is set automatically if there are any >5V contracts

        if ('Is Receive' in iDict ) and (iDict['Is Receive'] == True ) :
            self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Dual Role Data',
                                                                    'offset' : 25,
                                                                    'bit length' : 1}))

            self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'USB Capable',
                                                                    'offset' : 26,
                                                                    'bit length' : 1}))

            self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Externally Powered',
                                                                    'offset' : 27,
                                                                    'bit length' : 1}))

            self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Higher Capability',
                                                                    'offset' : 28,
                                                                    'bit length' : 1}))

            self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Dual Role Power',
                                                                    'offset' : 29,
                                                                    'bit length' : 1}))

        supplyType = register_class.cListDMTerminator( self.register,  { 'name' : 'Supply Type',
                                                                'offset' : 30,
                                                                'bit length' : 2})
        supplyType.help = """Select what type of supply this PDO will sink."""
        supplyType.setReportList(['Fixed Sink', 'Battery Sink', 'Variable Sink'])
        supplyType.addUpdateRegisterByName("self")
        supplyType.setMaxValue(2)

        fixedSupplyType = register_class.cForceSetDMTerminator( self.register,  { 'name' : 'Supply Type',
                                                                'offset' : 30,
                                                                'bit length' : 2,
                                                                'force value' : int(0),
                                                                'force display' : 'Fixed Sink',
                                                                'display widget' : supplyType })

        fixedSupplyType.help = """Supply Type that will source PDO1."""
        self.addChild(fixedSupplyType)
        fixedSupplyType.setFromInt(0)


        if (('No RDO Extensions' in iDict) and (iDict['No RDO Extensions'] == True)) or (('Is Receive' in iDict) and (iDict['Is Receive'] == True)) :
            pass
        else :
            self.addChild(cPDOCurrentField( self.register,  { 'name' : 'Maximum Operating Current',
                                                                    'offset' : 224,
                                                                    'bit length' : 10}))

            self.addChild(cPDOCurrentField( self.register,  { 'name' : 'Minimum Operating Current',
                                                                    'offset' : 234,
                                                                    'bit length' : 10}))

            self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Ask For Max',
                                                                    'offset' : 254,
                                                                    'bit length' : 1}))




class cDMVariableSourcePdoArray(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        self.addChild(cPDOCurrentField( self.register,  { 'name' : 'Maximum Current',
                                                                'offset' : 0,
                                                                'bit length' : 10}))

        self.addChild(cPDOVoltageField( self.register,  { 'name' : 'Minimum Voltage',
                                                                'offset' : 10,
                                                                'bit length' : 10}))

        self.addChild(cPDOVoltageField( self.register,  { 'name' : 'Maximum Voltage',
                                                                'offset' : 20,
                                                                'bit length' : 10}))

        supplyType = register_class.cListDMTerminator( self.register,  { 'name' : 'Supply Type',
                                                                'offset' : 30,
                                                                'bit length' : 2})
        supplyType.help = """Supply Type that will Source this PDO."""
        supplyType.setReportList(['Fixed Source', 'Battery Source', 'Variable Source'])
        supplyType.addUpdateRegisterByName("self")
        supplyType.setMaxValue(2)

        self.addChild(supplyType)


class cDMVariableSinkPdoArray(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        self.addChild(cPDOCurrentField( self.register,  { 'name' : 'Operating Current',
                                                                'offset' : 0,
                                                                'bit length' : 10}))

        self.addChild(cPDOVoltageField( self.register,  { 'name' : 'Minimum Voltage',
                                                                'offset' : 10,
                                                                'bit length' : 10}))

        self.addChild(cPDOVoltageField( self.register,  { 'name' : 'Maximum Voltage',
                                                                'offset' : 20,
                                                                'bit length' : 10}))

        supplyType = register_class.cListDMTerminator( self.register,  { 'name' : 'Supply Type',
                                                                'offset' : 30,
                                                                'bit length' : 2})
        supplyType.help = """Supply Type that will be used for this Sink PDO."""
        supplyType.setReportList(['Fixed Sink', 'Battery Sink', 'Variable Sink'])
        supplyType.addUpdateRegisterByName("self")
        supplyType.setMaxValue(2)

        self.addChild(supplyType)


        if ('No RDO Extensions' in iDict) and (iDict['No RDO Extensions'] == True) :
            pass
        else :
            self.addChild(cPDOCurrentField( self.register,  { 'name' : 'Maximum Operating Current',
                                                                    'offset' : 224,
                                                                    'bit length' : 10}))

            self.addChild(cPDOCurrentField( self.register,  { 'name' : 'Minimum Operating Current',
                                                                    'offset' : 234,
                                                                    'bit length' : 10}))

            self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Ask For Max',
                                                                    'offset' : 254,
                                                                    'bit length' : 1}))



class cDMBatterySourcePdoArray(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        self.addChild(cPDOPowerField( self.register,  { 'name' : 'Maximum Power',
                                                                'offset' : 0,
                                                                'bit length' : 10}))

        self.addChild(cPDOVoltageField( self.register,  { 'name' : 'Minimum Voltage',
                                                                'offset' : 10,
                                                                'bit length' : 10}))

        self.addChild(cPDOVoltageField( self.register,  { 'name' : 'Maximum Voltage',
                                                                'offset' : 20,
                                                                'bit length' : 10}))

        supplyType = register_class.cListDMTerminator( self.register,  { 'name' : 'Supply Type',
                                                                'offset' : 30,
                                                                'bit length' : 2})
        supplyType.help = """Supply type that will source this PDO."""
        supplyType.setReportList(['Fixed Source', 'Battery Source', 'Variable Source'])
        supplyType.addUpdateRegisterByName("self")
        supplyType.setMaxValue(2)

        self.addChild(supplyType)


class cDMBatterySinkPdoArray(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        self.addChild(cPDOPowerField( self.register,  { 'name' : 'Operating Power',
                                                                'offset' : 0,
                                                                'bit length' : 10}))

        self.addChild(cPDOVoltageField( self.register,  { 'name' : 'Minimum Voltage',
                                                                'offset' : 10,
                                                                'bit length' : 10}))

        self.addChild(cPDOVoltageField( self.register,  { 'name' : 'Maximum Voltage',
                                                                'offset' : 20,
                                                                'bit length' : 10}))

        supplyType = register_class.cListDMTerminator( self.register,  { 'name' : 'Supply Type',
                                                                'offset' : 30,
                                                                'bit length' : 2})
        supplyType.help = """Supply Type that will be used for this Sink PDO."""
        supplyType.setReportList(['Fixed Sink', 'Battery Sink', 'Variable Sink'])
        supplyType.addUpdateRegisterByName("self")
        supplyType.setMaxValue(2)

        self.addChild(supplyType)

        self.addChild(cPDOPowerField( self.register,  { 'name' : 'Maximum Operating Power',
                                                                'offset' : 224,
                                                                'bit length' : 10}))

        self.addChild(cPDOPowerField( self.register,  { 'name' : 'Minimum Operating Power',
                                                                'offset' : 234,
                                                                'bit length' : 10}))

        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Ask For Max',
                                                                'offset' : 254,
                                                                'bit length' : 1}))



# TODO : This is a common need. Build an extender class that takes an arbitrary data model in init and adds the
#        prepend and append capability.
class cDMAnySourcePdoArray(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        self.prependChildrenArray = []
        self.appendChildrenArray = []

        self.fixedOverlay = cDMFixedSourcePdoArray(register, self.tier, iDict)
        self.variableOverlay = cDMVariableSourcePdoArray(register, self.tier, iDict)
        self.batteryOverlay = cDMBatterySourcePdoArray(register, self.tier, iDict)

        # self.dataModelChildrenArray must contain the children in all three of the overlays
        self.dataModelChildrenArray = []
        self.dataModelChildrenArray.extend(self.fixedOverlay.dataModelChildrenArray)
        self.dataModelChildrenArray.extend(self.variableOverlay.dataModelChildrenArray)
        self.dataModelChildrenArray.extend(self.batteryOverlay.dataModelChildrenArray)

        self.dataModelGenerator = self.AnyPdoArrayDMGenerator

    def findDependentRegisters(self):
        # only update forcevals in current overlay
        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        if type == 0 :
            return self.fixedOverlay.findDependentRegisters() 
            
        elif type == 1 :
            return self.variableOverlay.findDependentRegisters() 

        elif type == 2:
            return self.batteryOverlay.findDependentRegisters() 

    def updateForceVal(self):
        # todo: should make a set parent call instead of allowing to be set directly
        #       then the objects can correctly set sub-object parent relationships
        self.fixedOverlay.parent = self.parent
        self.variableOverlay.parent = self.parent
        self.batteryOverlay.parent = self.parent

        # only update forcevals in current overlay
        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        if type == 0 :
            self.fixedOverlay.updateForceVal() 
            
        elif type == 1 :
            self.variableOverlay.updateForceVal() 

        elif type == 2:
            self.batteryOverlay.updateForceVal() 

    def maxPower(self) :
        power = 0.0
        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        if type == 0 :
            # 10 mA steps
            current = self.fixedOverlay.getChildByName('Maximum Current').valueToInt()
            # 50 mV steps
            voltage = self.fixedOverlay.getChildByName('Voltage').valueToInt()
            # 0.01 * 0.05 = .0005 Watts
            power = current * voltage * 0.0005

        if type == 1 :
            # 10 mA steps
            current = self.variableOverlay.getChildByName('Maximum Current').valueToInt()
            # 50 mV steps
            voltage = self.variableOverlay.getChildByName('Maximum Voltage').valueToInt()
            # 0.01 * 0.05 = .0005 Watts
            power = current * voltage * 0.0005

        if type == 2 :
            # reported in 250 mW steps
            power = self.batteryOverlay.getChildByName('Maximum Power').valueToInt() * 0.25

        return power

    def prependChild(self, child):
        self.prependChildrenArray[:0] = [child,]
        # it is okay to append to the dataModelChildrenArray because it is not directly used in the
        #    data model generator.
        self.dataModelChildrenArray.append(child)

    def addChild(self, child):
        child.parent = self
        self.appendChildrenArray.append(child)
        self.dataModelChildrenArray.append(child)

    # return the first child with a matching name or none if no match
    def getChildByName(self, name):
        for child in self.prependChildrenArray :
            if child.name == name :
                return child

        for child in self.appendChildrenArray :
            if child.name == name :
                return child

        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        if type == 0 :
            for child in self.fixedOverlay :
                if child.name == name :
                    return child
        elif type == 1 :
            for child in self.variableOverlay :
                if child.name == name :
                    return child
        elif type == 2:
            for child in self.batteryOverlay :
                if child.name == name :
                    return child

        return None

    def AnyPdoArrayDMGenerator(self):
        # todo: should make a set parent call instead of allowing to be set directly
        #       then the objects can correctly set sub-object parent relationships
        self.fixedOverlay.parent = self.parent
        self.variableOverlay.parent = self.parent
        self.batteryOverlay.parent = self.parent

        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        retDict = {'name' : self.name, 'grouping tier' : self.tier, 'show' : self.show, 'data model list' : []}
        if type == 0 :
            for child in self.prependChildrenArray :
                if isinstance(child, dict) :
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else :
                    retDict['data model list'].append(child.dataModelGenerator())
            retDict['data model list'].extend(self.fixedOverlay.dataModelGenerator()['data model list'])
            for child in self.appendChildrenArray :
                if isinstance(child, list) :
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else :
                    retDict['data model list'].append(child.dataModelGenerator())
        elif type == 1:
            for child in self.prependChildrenArray :
                if isinstance(child, list) :
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else :
                    retDict['data model list'].append(child.dataModelGenerator())
            retDict['data model list'].extend(self.batteryOverlay.dataModelGenerator()['data model list'])
            for child in self.appendChildrenArray :
                if isinstance(child, list) :
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else :
                    retDict['data model list'].append(child.dataModelGenerator())
        elif type == 2 :
            for child in self.prependChildrenArray :
                if isinstance(child, list) :
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else :
                    retDict['data model list'].append(child.dataModelGenerator())
            retDict['data model list'].extend(self.variableOverlay.dataModelGenerator()['data model list'])
            for child in self.appendChildrenArray :
                if isinstance(child, list) :
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else :
                    retDict['data model list'].append(child.dataModelGenerator())
        else :
            # invalid setting
            # TODO: improve error handling
            retDict['data model list'] = []

        return retDict


class cDMAnySinkPdoArray(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        self.prependChildrenArray = []
        self.appendChildrenArray = []

        self.fixedOverlay = cDMFixedSinkPdoArray(register, self.tier, iDict)
        self.variableOverlay = cDMVariableSinkPdoArray(register, self.tier, iDict)
        self.batteryOverlay = cDMBatterySinkPdoArray(register, self.tier, iDict)

        # self.dataModelChildrenArray must contain the children in all three of the overlays
        self.dataModelChildrenArray = []
        self.dataModelChildrenArray.extend(self.fixedOverlay.dataModelChildrenArray)
        self.dataModelChildrenArray.extend(self.variableOverlay.dataModelChildrenArray)
        self.dataModelChildrenArray.extend(self.batteryOverlay.dataModelChildrenArray)

        self.dataModelGenerator = self.AnyPdoArrayDMGenerator

    def findDependentRegisters(self):
        # only update forcevals in current overlay
        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        if type == 0 :
            return self.fixedOverlay.findDependentRegisters() 
            
        elif type == 1 :
            return self.variableOverlay.findDependentRegisters() 

        elif type == 2:
            return self.batteryOverlay.findDependentRegisters() 

    def updateForceVal(self):
        # todo: should make a set parent call instead of allowing to be set directly
        #       then the objects can correctly set sub-object parent relationships
        self.fixedOverlay.parent = self.parent
        self.variableOverlay.parent = self.parent
        self.batteryOverlay.parent = self.parent

        # only update forcevals in current overlay
        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        if type == 0 :
            self.fixedOverlay.updateForceVal() 
            
        elif type == 1 :
            self.variableOverlay.updateForceVal() 

        elif type == 2:
            self.batteryOverlay.updateForceVal() 

    def prependChild(self, child):
        self.prependChildrenArray[:0] = [child,]
        # it is okay to append to the dataModelChildrenArray because it is not directly used in the
        #    data model generator.
        self.dataModelChildrenArray.append(child)

    def addChild(self, child):
        child.parent = self
        self.appendChildrenArray.append(child)
        self.dataModelChildrenArray.append(child)

    # return the first child with a matching name or none if no match
    def getChildByName(self, name):
        for child in self.prependChildrenArray :
            if child.name == name :
                return child

        for child in self.appendChildrenArray :
            if child.name == name :
                return child

        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        if type == 0 :
            for child in self.fixedOverlay :
                if child.name == name :
                    return child
        elif type == 1 :
            for child in self.variableOverlay :
                if child.name == name :
                    return child
        elif type == 2:
            for child in self.batteryOverlay :
                if child.name == name :
                    return child

        return None

    def AnyPdoArrayDMGenerator(self):
        # todo: should make a set parent call instead of allowing to be set directly
        #       then the objects can correctly set sub-object parent relationships
        self.fixedOverlay.parent = self.parent
        self.variableOverlay.parent = self.parent
        self.batteryOverlay.parent = self.parent

        type = self.fixedOverlay.getChildByName('Supply Type').valueToInt()
        retDict = {'name' : self.name, 'grouping tier' : self.tier, 'show' : self.show, 'data model list' : []}
        if type == 0 :
            for child in self.prependChildrenArray :
                if isinstance(child, dict) :
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else :
                    retDict['data model list'].append(child.dataModelGenerator())
            retDict['data model list'].extend(self.fixedOverlay.dataModelGenerator()['data model list'])
            for child in self.appendChildrenArray :
                if isinstance(child, list) :
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else :
                    retDict['data model list'].append(child.dataModelGenerator())
        elif type == 1:
            for child in self.prependChildrenArray :
                if isinstance(child, list) :
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else :
                    retDict['data model list'].append(child.dataModelGenerator())
            retDict['data model list'].extend(self.batteryOverlay.dataModelGenerator()['data model list'])
            for child in self.appendChildrenArray :
                if isinstance(child, list) :
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else :
                    retDict['data model list'].append(child.dataModelGenerator())
        elif type == 2 :
            for child in self.prependChildrenArray :
                if isinstance(child, list) :
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else :
                    retDict['data model list'].append(child.dataModelGenerator())
            retDict['data model list'].extend(self.variableOverlay.dataModelGenerator()['data model list'])
            for child in self.appendChildrenArray :
                if isinstance(child, list) :
                    retDict['data model list'].extend(child.dataModelGenerator()['data model list'])
                else :
                    retDict['data model list'].append(child.dataModelGenerator())
        else :
            # invalid setting
            # TODO: improve error handling
            retDict['data model list'] = []

        return retDict


class cUFPIDHeaderVDO(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        self.addChild(register_class.cHexDMTerminator( self.register,  { 'name' : 'USB Vendor ID',
                                                                'offset' : 0,
                                                                'bit length' : 16}))

        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Modal Operation Supported',
                                                                'offset' : 26,
                                                                'bit length' : 1}))

        productType = register_class.cListDMTerminator( self.register,  { 'name' : 'Product Type',
                                                                'offset' : 27,
                                                                'bit length' : 3})
        productType.setMaxValue(6)
        productType.setReportList(['Undefined', 'Hub', 'Peripheral', 'Passive Cable', 'Active Cable', 'Alternate Mode Adapter', 'Power Brick'])

        self.addChild(productType)

        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Data Capable as USB Device',
                                                                'offset' : 30,
                                                                'bit length' : 1}))

        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'Data Capable as USB Host',
                                                                'offset' : 31,
                                                                'bit length' : 1}))


class cUFPProductVDO(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        self.addChild(register_class.cHexDMTerminator( self.register,  { 'name' : 'BCD Device',
                                                                'offset' : 0,
                                                                'bit length' : 16}))

        self.addChild(register_class.cHexDMTerminator( self.register,  { 'name' : 'USB Product ID',
                                                                'offset' : 16,
                                                                'bit length' : 16}))


class cCableVDO(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        usbSSSignal = register_class.cListDMTerminator( self.register,  { 'name' : 'USB SS Signalling',
                                                                'offset' : 0,
                                                                'bit length' : 3})
        usbSSSignal.setMaxValue(2)
        usbSSSignal.setReportList(['USB 2.0 Only', 'USB 3.1 Gen 1', 'USB 3.1 Gen 1 and 2'])

        self.addChild(usbSSSignal)

        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'SOP" Controller Present',
                                                                'offset' : 3,
                                                                'bit length' : 1}))

        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'VBus Through Cable',
                                                                'offset' : 4,
                                                                'bit length' : 1}))

        currentCap = register_class.cListDMTerminator( self.register,  { 'name' : 'VBus Current Capability',
                                                                'offset' : 5,
                                                                'bit length' : 2})
        currentCap.setMaxValue(3)
        currentCap.setReportList(['1.5 A', '3.0 A', '5 A'])

        self.addChild(currentCap)

        ssrx2dir = register_class.cListDMTerminator( self.register,  { 'name' : 'SSRx 2 Directionality',
                                                                'offset' : 7,
                                                                'bit length' : 1})
        ssrx2dir.setReportList(['Fixed', 'Configurable'])

        self.addChild(ssrx2dir)

        ssrx1dir = register_class.cListDMTerminator( self.register,  { 'name' : 'SSRx 1 Directionality',
                                                                'offset' : 8,
                                                                'bit length' : 1})
        ssrx1dir.setReportList(['Fixed', 'Configurable'])

        self.addChild(ssrx1dir)

        sstx2dir = register_class.cListDMTerminator( self.register,  { 'name' : 'SSTx 2 Directionality',
                                                                'offset' : 9,
                                                                'bit length' : 1})
        sstx2dir.setReportList(['Fixed', 'Configurable'])

        self.addChild(sstx2dir)

        sstx1dir = register_class.cListDMTerminator( self.register,  { 'name' : 'SSTx 1 Directionality',
                                                                'offset' : 10,
                                                                'bit length' : 1})
        sstx1dir.setReportList(['Fixed', 'Configurable'])

        self.addChild(sstx1dir)

        cableTerm = register_class.cListDMTerminator( self.register,  { 'name' : 'Cable Termination Type',
                                                                'offset' : 11,
                                                                'bit length' : 2})
        cableTerm.setReportList(['Both Ends Passive, VConn Not Required', 'Both Ends Passive, VConn Is Required', 'One End Active, One End Passive, VConn Is Required', 'Both Ends Active, VConn Is Required'])

        self.addChild(cableTerm)

        cableLat = register_class.cListDMTerminator( self.register,  { 'name' : 'Cable Latency',
                                                                'offset' : 13,
                                                                'bit length' : 4})

        cableLat.setMaxValue(10)
        cableLat.setReportList(['reserved (0000b)', '< 10nS (~1m)', '10-20nS (~2m)', '20-30nS (~3m)', '30-40nS (~4m)', '40-50nS (~5m)', '50-60nS (~6m)', '60-70nS (~7m)', '1000nS (~100m)', '2000nS (~200m)', '3000nS (~300m)'])

        self.addChild(cableLat)

        plugRec = register_class.cListDMTerminator( self.register,  { 'name' : 'Type-C Plug/Receptacle',
                                                                'offset' : 17,
                                                                'bit length' : 1})

        plugRec.setMaxValue(10)
        plugRec.setReportList(['Plug', 'Receptacle'])

        self.addChild(plugRec)

        typeCto = register_class.cListDMTerminator( self.register,  { 'name' : 'Type-C to Type-A/B/C',
                                                                'offset' : 18,
                                                                'bit length' : 2})

        typeCto.setMaxValue(2)
        typeCto.setReportList(['Type-A', 'Type-B', 'Type-C'])

        self.addChild(typeCto)

        self.addChild(register_class.cHexDMTerminator( self.register,  { 'name' : 'Cable Firmware Version',
                                                                'offset' : 24,
                                                                'bit length' : 4}))

        self.addChild(register_class.cHexDMTerminator( self.register,  { 'name' : 'Cable Hardware Version',
                                                                'offset' : 28,
                                                                'bit length' : 4}))


class cAMAVDO(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)
        #
        usbSSSignal = register_class.cListDMTerminator( self.register,  { 'name' : 'USB SS Signalling',
                                                                'offset' : 0,
                                                                'bit length' : 3})
        usbSSSignal.setMaxValue(3)
        usbSSSignal.setReportList(['USB 2.0 Only', 'USB 3.1 Gen 1', 'USB 3.1 Gen 1 and 2', 'USB 2.0 Billboard Only'])

        self.addChild(usbSSSignal)

        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'VBus Required',
                                                                'offset' : 3,
                                                                'bit length' : 1}))

        self.addChild(register_class.cBooleanDMTerminator( self.register,  { 'name' : 'VConn Required',
                                                                'offset' : 4,
                                                                'bit length' : 1}))

        vConnPower = register_class.cListDMTerminator( self.register,  { 'name' : 'VConn Power',
                                                                'offset' : 5,
                                                                'bit length' : 3})
        vConnPower.setMaxValue(6)
        vConnPower.setReportList(['1 W', '1.5 W', '2 W', '3 W', '4 W', '5 W', '6 W'])

        self.addChild(vConnPower)

        ssrx2dir = register_class.cListDMTerminator( self.register,  { 'name' : 'SSRx 2 Directionality',
                                                                'offset' : 8,
                                                                'bit length' : 1})
        ssrx2dir.setReportList(['Fixed', 'Configurable'])

        self.addChild(ssrx2dir)

        ssrx1dir = register_class.cListDMTerminator( self.register,  { 'name' : 'SSRx 1 Directionality',
                                                                'offset' : 9,
                                                                'bit length' : 1})
        ssrx1dir.setReportList(['Fixed', 'Configurable'])

        self.addChild(ssrx1dir)

        sstx2dir = register_class.cListDMTerminator( self.register,  { 'name' : 'SSTx 2 Directionality',
                                                                'offset' : 10,
                                                                'bit length' : 1})
        sstx2dir.setReportList(['Fixed', 'Configurable'])

        self.addChild(sstx2dir)

        sstx1dir = register_class.cListDMTerminator( self.register,  { 'name' : 'SSTx 1 Directionality',
                                                                'offset' : 11,
                                                                'bit length' : 1})
        sstx1dir.setReportList(['Fixed', 'Configurable'])

        self.addChild(sstx1dir)

        self.addChild(register_class.cHexDMTerminator( self.register,  { 'name' : 'AMA Firmware Version',
                                                                'offset' : 24,
                                                                'bit length' : 4}))

        self.addChild(register_class.cHexDMTerminator( self.register,  { 'name' : 'AMA Hardware Version',
                                                                'offset' : 28,
                                                                'bit length' : 4}))



#==========================================================================
# main registers
#==========================================================================

VID_COMMON_TI = 0x28

class cVID_0x00_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'VID',
                                                 'address' : 0x00,
                                                 'byte length' : 4,
                                                 'permission' : 'RO'})

        self.setAsShared()
        self.hide()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'VID',
                                                        'offset' : 0,
                                                        'bit length' : 32 })


        VID = register_class.cForceSetDMTerminator(self,
                                                        {'name': 'Intel-assigned Thunderbolt Vendor ID',
                                                         'offset': 0,
                                                         'bit length': 32,
                                                         'force value': int(VID_COMMON_TI),
                                                         'force display': str(VID_COMMON_TI)})

        # VID = register_class.cHexDMTerminator(self,
        #                                                    {'name': 'Intel-assigned Thunderbolt Vendor ID',
        #                                                     'offset': 0,
        #                                                     'bit length': 32})

        self.dataModel.addChild(VID)



def intFrom4CC(value) :
    retVal = 0x0
    # little endian. First char takes position 0 of the array
    for (i,char) in enumerate(value) :
        retVal |= (ord(char) << (8*i))

    return retVal



DID_ACE = "ACE1"

DID_OF_DEVICE_STR =  DID_ACE
DID_OF_DEVICE_INT =  intFrom4CC(DID_ACE)

class cDID_0x01_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'DID',
                                                 'address' : 0x01,
                                                 'byte length' : 4,
                                                 'permission' : 'RO'})

        self.setAsShared()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'DID',
                                                        'offset' : 0,
                                                        'bit length' : 32 })

        self.hide()

        DID = register_class.cForceSetDMTerminator(self,
                                                        {'name': 'Vendor-specific Device ID.',
                                                         'offset': 0,
                                                         'bit length': 32,
                                                         'force value': int(DID_OF_DEVICE_INT),
                                                         'force display': str(DID_OF_DEVICE_STR)})


        self.dataModel.addChild(DID)

class cProtoVer_0x02_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Protocol Version',
                                                 'address' : 0x02,
                                                 'byte length' : 4,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Protocol Version',
                                                        'offset' : 0,
                                                        'bit length' : 32 })

        tbtVer = register_class.cForceSetDMTerminator( self,  { 'name' : 'Thunderbolt(TM) Protocol Version',
                                                                'offset' : 0,
                                                                'bit length' : 32,
                                                                'force value' : int(1),
                                                                'force display' : '1'})

        self.dataModel.addChild(tbtVer)
        tbtVer.setFromInt(1)


class cMode_0x03_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Mode',
                                                 'address' : 0x03,
                                                 'byte length' : 4,
                                                 'permission' : 'DRO'})

        self.setAsShared()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Mode',
                                                        'offset' : 0,
                                                        'bit length' : 32 })
        mode = register_class.cAsciiDMTerminator(self,
                                                        {'name' : 'Mode',
                                                         'offset' : 0,
                                                         'bit length' : 32 })
        mode.help = """4-character string to indicate mode of device"""
        self.dataModel.addChild(mode)


class cCustUse_0x06_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Customer Use',
                                                 'address' : 0x06,
                                                 'byte length' : 8,
                                                 'permission' : 'RO'})

        self.setAsShared()

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Customer Use',
                                                        'offset' : 0,
                                                        'bit length' : 64 })

        svid = register_class.cHexDMTerminator(self,
                                                      {'name' : 'Customer Use Word 1',
                                                        'offset' : 0,
                                                        'bit length' : 32 })

        svid.help = """The customer use register is a read-only register that is configured at build time using the configuration tool. It stores an arbitrary value that may be read from the customer use register (0x06) at run time.

Common uses of this register include platform identifiers, configuration version numbers and date codes."""

        self.dataModel.addChild(svid)

        svid = register_class.cHexDMTerminator(self,
                                                      {'name' : 'Customer Use Word 2',
                                                        'offset' : 32,
                                                        'bit length' : 32 })

        svid.help = """The customer use register is a read-only register that is configured at build time using the configuration tool. It stores an arbitrary value that may be read from the customer use register (0x06) at run time.

Common uses of this register include platform identifiers, configuration version numbers and date codes."""

        self.dataModel.addChild(svid)


class cIntMask1_0x16_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Interrupt Mask for I2C1',
                                                 'address' : 0x16,
                                                 'byte length' : 8,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Interrupt Mask for I2C1',
                                                        'offset' : 0,
                                                        'bit length' : 64 })

        SoftReset = register_class.cForceSetDMTerminator( self,  { 'name' : 'Soft Reset',
                                                                'offset' : 0,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(SoftReset)
        SoftReset.setFromInt(0)

        HardReset = register_class.cForceSetDMTerminator( self,  { 'name' : 'Hard Reset',
                                                                'offset' : 1,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(HardReset)
        HardReset.setFromInt(0)

        PowerPathEvent = register_class.cForceSetDMTerminator( self,  { 'name' : 'Power Path Event',
                                                                'offset' : 2,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(PowerPathEvent)
        PowerPathEvent.setFromInt(0)

        PlugInsertOrRemoval = register_class.cForceSetDMTerminator( self,  { 'name' : 'Plug Insert or Removal',
                                                                'offset' : 3,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        self.dataModel.addChild(PlugInsertOrRemoval)
        PlugInsertOrRemoval.setFromInt(1)


        PRSwapComplete = register_class.cForceSetDMTerminator( self,  { 'name' : 'PR Swap Complete',
                                                                'offset' : 4,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(PRSwapComplete)
        PRSwapComplete.setFromInt(0)


        DRSwapComplete = register_class.cForceSetDMTerminator( self,  { 'name' : 'DR Swap Complete',
                                                                'offset' : 5,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(DRSwapComplete)
        DRSwapComplete.setFromInt(0)


        AwokenByHost = register_class.cForceSetDMTerminator( self,  { 'name' : 'Awoken by Host',
                                                                'offset' : 6,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(AwokenByHost)
        AwokenByHost.setFromInt(0)


        RdoReceivedFromSink = register_class.cForceSetDMTerminator( self,  { 'name' : 'RDO Received from Sink',
                                                                'offset' : 7,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(RdoReceivedFromSink)
        RdoReceivedFromSink.setFromInt(0)


        Bist = register_class.cForceSetDMTerminator( self,  { 'name' : 'Built-In Self Test',
                                                                'offset' : 8,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Bist)
        Bist.setFromInt(0)


        Overcurrent = register_class.cForceSetDMTerminator( self,  { 'name' : 'Overcurrent Event',
                                                                'offset' : 9,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Overcurrent)
        Overcurrent.setFromInt(0)


        AttentionReceived = register_class.cForceSetDMTerminator( self,  { 'name' : 'Attention Received',
                                                                'offset' : 10,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(AttentionReceived)
        AttentionReceived.setFromInt(0)


        VDMReceived = register_class.cForceSetDMTerminator( self,  { 'name' : 'Vendor-Defined Message Received',
                                                                'offset' : 11,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(VDMReceived)
        VDMReceived.setFromInt(0)


        NewContractAsCons = register_class.cForceSetDMTerminator( self,  { 'name' : 'New Contract as Consumer',
                                                                'offset' : 12,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(NewContractAsCons)
        NewContractAsCons.setFromInt(0)


        NewContractAsProv = register_class.cForceSetDMTerminator( self,  { 'name' : 'New Contract as Provider',
                                                                'offset' : 13,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(NewContractAsProv)
        NewContractAsProv.setFromInt(0)


        SourceCapMsgReady = register_class.cForceSetDMTerminator( self,  { 'name' : 'Source Capabilities Message Ready',
                                                                'offset' : 14,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(SourceCapMsgReady)
        SourceCapMsgReady.setFromInt(0)


        SinkCapMsgReady = register_class.cForceSetDMTerminator( self,  { 'name' : 'Sink Capabilities Message Ready',
                                                                'offset' : 15,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(SinkCapMsgReady)
        SinkCapMsgReady.setFromInt(0)


        SwapRequested = register_class.cForceSetDMTerminator( self,  { 'name' : 'Swap Requested',
                                                                'offset' : 17,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(SwapRequested)
        SwapRequested.setFromInt(0)


        BISTMessageIgnored = register_class.cForceSetDMTerminator( self,  { 'name' : 'BIST Message Ignored',
                                                                'offset' : 18,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(BISTMessageIgnored)
        BISTMessageIgnored.setFromInt(0)


        GotoMinReceived = register_class.cForceSetDMTerminator( self,  { 'name' : 'GotoMin Received',
                                                                'offset' : 19,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(GotoMinReceived)
        GotoMinReceived.setFromInt(0)


        UsbHostPresent = register_class.cForceSetDMTerminator( self,  { 'name' : 'USB Host Present',
                                                                'offset' : 20,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(UsbHostPresent)
        UsbHostPresent.setFromInt(0)


        UsbHostPresentNoLonger = register_class.cForceSetDMTerminator( self,  { 'name' : 'USB Host Present No Longer',
                                                                'offset' : 21,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(UsbHostPresentNoLonger)
        UsbHostPresentNoLonger.setFromInt(0)


        HighVoltageWarning = register_class.cForceSetDMTerminator( self,  { 'name' : 'High Voltage Warning',
                                                                'offset' : 22,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(HighVoltageWarning)
        HighVoltageWarning.setFromInt(0)


        PPswitchChanged = register_class.cForceSetDMTerminator( self,  { 'name' : 'Power Path Switch Changed',
                                                                'offset' : 23,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(PPswitchChanged)
        PPswitchChanged.setFromInt(0)


        PowerStatusUpdate = register_class.cForceSetDMTerminator( self,  { 'name' : 'Power Status Update',
                                                                'offset' : 24,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(PowerStatusUpdate)
        PowerStatusUpdate.setFromInt(0)


        DataStatusUpdate = register_class.cForceSetDMTerminator( self,  { 'name' : 'Data Status Update',
                                                                'offset' : 25,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        self.dataModel.addChild(DataStatusUpdate)
        DataStatusUpdate.setFromInt(1)


        StatusUpdate = register_class.cForceSetDMTerminator( self,  { 'name' : 'Status Update',
                                                                'offset' : 26,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(StatusUpdate)
        StatusUpdate.setFromInt(0)


        PDStatusUpdate = register_class.cForceSetDMTerminator( self,  { 'name' : 'PD Status Update',
                                                                'offset' : 27,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(PDStatusUpdate)
        PDStatusUpdate.setFromInt(0)


        ADCLowThreshold = register_class.cForceSetDMTerminator( self,  { 'name' : 'ADC Low Threshold',
                                                                'offset' : 28,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(ADCLowThreshold)
        ADCLowThreshold.setFromInt(0)


        ADCHighThreshold = register_class.cForceSetDMTerminator( self,  { 'name' : 'ADC High Threshold',
                                                                'offset' : 29,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(ADCHighThreshold)
        ADCHighThreshold.setFromInt(0)

        Cmd1Complete = register_class.cForceSetDMTerminator( self,  { 'name' : 'CMD1 Complete',
                                                                'offset' : 30,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Cmd1Complete)
        Cmd1Complete.setFromInt(0)


        Cmd2Complete = register_class.cForceSetDMTerminator( self,  { 'name' : 'CMD2 Complete',
                                                                'offset' : 31,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Cmd2Complete)
        Cmd2Complete.setFromInt(0)

        Error_DeviceIncompatible = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Device Incompatible',
                                                                'offset' : 32,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_DeviceIncompatible)
        Error_DeviceIncompatible.setFromInt(0)

        Error_CannotProvideVoltageOrCurrent = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Cannot Provide Voltage or Current',
                                                                'offset' : 33,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_CannotProvideVoltageOrCurrent)
        Error_CannotProvideVoltageOrCurrent.setFromInt(0)


        Error_CanProvideVoltageOrCurrentLater = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Cannot Provide Voltage or Current Later',
                                                                'offset' : 34,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_CanProvideVoltageOrCurrentLater)
        Error_CanProvideVoltageOrCurrentLater.setFromInt(0)

        Error_PowerEventOccurred = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Power Event Occurred',
                                                                'offset' : 35,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_PowerEventOccurred)
        Error_PowerEventOccurred.setFromInt(0)

        Error_MissingGetCapMessage = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Missing Get Capabilities Message',
                                                                'offset' : 36,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_MissingGetCapMessage)
        Error_MissingGetCapMessage.setFromInt(0)

        Error_ProtocolError = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Protocol Error',
                                                                'offset' : 38,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_ProtocolError)
        Error_ProtocolError.setFromInt(0)

        Error_MessageData = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Message Data',
                                                                'offset' : 39,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_MessageData)
        Error_MessageData.setFromInt(0)

        Error_DischargeFailed = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Discharge Failed',
                                                                'offset' : 41,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_DischargeFailed)
        Error_DischargeFailed.setFromInt(0)

        SnkTransitionComplete = register_class.cForceSetDMTerminator( self,  { 'name' : 'Sink Transition Complete',
                                                                'offset' : 42,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(SnkTransitionComplete)
        SnkTransitionComplete.setFromInt(0)

        Error_UnableToSource = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Unable to Source',
                                                                'offset' : 46,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_UnableToSource)
        Error_UnableToSource.setFromInt(0)

        UserSvidModeEntered = register_class.cForceSetDMTerminator( self,  { 'name' : 'User SVID Mode Entered',
                                                                'offset' : 56,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(UserSvidModeEntered)
        UserSvidModeEntered.setFromInt(0)

        UserSvidModeExited = register_class.cForceSetDMTerminator( self,  { 'name' : 'User SVID Mode Exited',
                                                                'offset' : 57,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(UserSvidModeExited)
        UserSvidModeExited.setFromInt(0)

        UserSvidAttentionVDMReceived = register_class.cForceSetDMTerminator( self,  { 'name' : 'User SVID Attention VDM Received',
                                                                'offset' : 58,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(UserSvidAttentionVDMReceived)
        UserSvidAttentionVDMReceived.setFromInt(0)

        UserSvidOtherVDMReceived = register_class.cForceSetDMTerminator( self,  { 'name' : 'User SVID Other VDM Received',
                                                                'offset' : 59,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(UserSvidOtherVDMReceived)
        UserSvidOtherVDMReceived.setFromInt(0)



class cData1_0x09_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Data Register for CMD1',
                                                 'address' : 0x09,
                                                 'byte length' : 4,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Data Register for CMD1',
                                                        'offset' : 0,
                                                        'bit length' : 32 })


        word1 = register_class.cHexDMTerminator(self,
                                                                    {'name' : 'Word 1 (Least Significant)',
                                                                     'offset' : 0,
                                                                     'bit length' : 32 })

        self.dataModel.addChild(word1)

#        word2 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 2',
#                                                                     'offset' : 32,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word2)

#        word3 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 3',
#                                                                     'offset' : 64,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word3)

#        word4 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 4',
#                                                                     'offset' : 96,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word4)

#        word5 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 5',
#                                                                     'offset' : 128,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word5)

#        word6 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 6',
#                                                                     'offset' : 160,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word6)

#        word7 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 7',
#                                                                     'offset' : 192,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word7)

#        word8 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 8',
#                                                                     'offset' : 224,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word8)

#        word9 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 9',
#                                                                     'offset' : 256,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word9)

#        word10 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 10',
#                                                                     'offset' : 288,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word10)

#        word11 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 11',
#                                                                     'offset' : 320,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word11)

#        word12 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 12',
#                                                                     'offset' : 352,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word12)

#        word13 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 13',
#                                                                     'offset' : 384,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word13)

#        word14 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 14',
#                                                                     'offset' : 416,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word14)

#        word15 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 15',
#                                                                     'offset' : 448,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word15)

#        word16 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 16',
#                                                                     'offset' : 480,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word16)


class cData2_0x11_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Data Register for CMD2',
                                                 'address' : 0x11,
                                                 'byte length' : 4,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Data Register for CMD1',
                                                        'offset' : 0,
                                                        'bit length' : 32 })


        word1 = register_class.cHexDMTerminator(self,
                                                                    {'name' : 'Word 1 (Least Significant)',
                                                                     'offset' : 0,
                                                                     'bit length' : 32 })

        self.dataModel.addChild(word1)

#        word2 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 2',
#                                                                     'offset' : 32,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word2)

#        word3 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 3',
#                                                                     'offset' : 64,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word3)

#        word4 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 4',
#                                                                     'offset' : 96,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word4)

#        word5 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 5',
#                                                                     'offset' : 128,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word5)

#        word6 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 6',
#                                                                     'offset' : 160,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word6)

#        word7 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 7',
#                                                                     'offset' : 192,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word7)

#        word8 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 8',
#                                                                     'offset' : 224,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word8)

#        word9 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 9',
#                                                                     'offset' : 256,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word9)

#        word10 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 10',
#                                                                     'offset' : 288,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word10)

#        word11 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 11',
#                                                                     'offset' : 320,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word11)

#        word12 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 12',
#                                                                     'offset' : 352,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word12)

#        word13 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 13',
#                                                                     'offset' : 384,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word13)

#        word14 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 14',
#                                                                     'offset' : 416,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word14)

#        word15 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 15',
#                                                                     'offset' : 448,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word15)

#        word16 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 16',
#                                                                     'offset' : 480,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word16)


class cData3_0x1F_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Data Register for CMD3',
                                                 'address' : 0x1F,
                                                 'byte length' : 4,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Data Register for CMD1',
                                                        'offset' : 0,
                                                        'bit length' : 32 })


        word1 = register_class.cHexDMTerminator(self,
                                                                    {'name' : 'Word 1 (Least Significant)',
                                                                     'offset' : 0,
                                                                     'bit length' : 32 })

        self.dataModel.addChild(word1)

#        word2 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 2',
#                                                                     'offset' : 32,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word2)

#        word3 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 3',
#                                                                     'offset' : 64,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word3)

#        word4 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 4',
#                                                                     'offset' : 96,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word4)

#        word5 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 5',
#                                                                     'offset' : 128,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word5)

#        word6 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 6',
#                                                                     'offset' : 160,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word6)

#        word7 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 7',
#                                                                     'offset' : 192,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word7)

#        word8 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 8',
#                                                                     'offset' : 224,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word8)

#        word9 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 9',
#                                                                     'offset' : 256,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word9)

#        word10 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 10',
#                                                                     'offset' : 288,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word10)

#        word11 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 11',
#                                                                     'offset' : 320,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word11)

#        word12 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 12',
#                                                                     'offset' : 352,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word12)

#        word13 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 13',
#                                                                     'offset' : 384,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word13)

#        word14 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 14',
#                                                                     'offset' : 416,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word14)

#        word15 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 15',
#                                                                     'offset' : 448,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word15)

#        word16 = register_class.cHexDMTerminator(self,
#                                                                    {'name' : 'Word 16',
#                                                                     'offset' : 480,
#                                                                     'bit length' : 32 })

#        self.dataModel.addChild(word16)





class cIntMask2_0x17_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Interrupt Mask for I2C2',
                                                 'address' : 0x17,
                                                 'byte length' : 8,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Interrupt Mask for I2C2',
                                                        'offset' : 0,
                                                        'bit length' : 64 })


        SoftReset = register_class.cForceSetDMTerminator( self,  { 'name' : 'Soft Reset',
                                                                'offset' : 0,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(SoftReset)
        SoftReset.setFromInt(0)

        HardReset = register_class.cForceSetDMTerminator( self,  { 'name' : 'Hard Reset',
                                                                'offset' : 1,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(HardReset)
        HardReset.setFromInt(0)

        PowerPathEvent = register_class.cForceSetDMTerminator( self,  { 'name' : 'Power Path Event',
                                                                'offset' : 2,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(PowerPathEvent)
        PowerPathEvent.setFromInt(0)

        PlugInsertOrRemoval = register_class.cForceSetDMTerminator( self,  { 'name' : 'Plug Insert or Removal',
                                                                'offset' : 3,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        self.dataModel.addChild(PlugInsertOrRemoval)
        PlugInsertOrRemoval.setFromInt(1)


        PRSwapComplete = register_class.cForceSetDMTerminator( self,  { 'name' : 'PR Swap Complete',
                                                                'offset' : 4,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(PRSwapComplete)
        PRSwapComplete.setFromInt(0)


        DRSwapComplete = register_class.cForceSetDMTerminator( self,  { 'name' : 'DR Swap Complete',
                                                                'offset' : 5,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(DRSwapComplete)
        DRSwapComplete.setFromInt(0)


        AwokenByHost = register_class.cForceSetDMTerminator( self,  { 'name' : 'Awoken by Host',
                                                                'offset' : 6,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(AwokenByHost)
        AwokenByHost.setFromInt(0)


        RdoReceivedFromSink = register_class.cForceSetDMTerminator( self,  { 'name' : 'RDO Received from Sink',
                                                                'offset' : 7,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(RdoReceivedFromSink)
        RdoReceivedFromSink.setFromInt(0)


        Bist = register_class.cForceSetDMTerminator( self,  { 'name' : 'Built-In Self Test',
                                                                'offset' : 8,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Bist)
        Bist.setFromInt(0)


        Overcurrent = register_class.cForceSetDMTerminator( self,  { 'name' : 'Overcurrent Event',
                                                                'offset' : 9,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Overcurrent)
        Overcurrent.setFromInt(0)


        AttentionReceived = register_class.cForceSetDMTerminator( self,  { 'name' : 'Attention Received',
                                                                'offset' : 10,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(AttentionReceived)
        AttentionReceived.setFromInt(0)


        VDMReceived = register_class.cForceSetDMTerminator( self,  { 'name' : 'Vendor-Defined Message Received',
                                                                'offset' : 11,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(VDMReceived)
        VDMReceived.setFromInt(0)


        NewContractAsCons = register_class.cForceSetDMTerminator( self,  { 'name' : 'New Contract as Consumer',
                                                                'offset' : 12,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(NewContractAsCons)
        NewContractAsCons.setFromInt(0)


        NewContractAsProv = register_class.cForceSetDMTerminator( self,  { 'name' : 'New Contract as Provider',
                                                                'offset' : 13,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(NewContractAsProv)
        NewContractAsProv.setFromInt(0)


        SourceCapMsgReady = register_class.cForceSetDMTerminator( self,  { 'name' : 'Source Capabilities Message Ready',
                                                                'offset' : 14,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(SourceCapMsgReady)
        SourceCapMsgReady.setFromInt(0)


        SinkCapMsgReady = register_class.cForceSetDMTerminator( self,  { 'name' : 'Sink Capabilities Message Ready',
                                                                'offset' : 15,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(SinkCapMsgReady)
        SinkCapMsgReady.setFromInt(0)


        SwapRequested = register_class.cForceSetDMTerminator( self,  { 'name' : 'Swap Requested',
                                                                'offset' : 17,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(SwapRequested)
        SwapRequested.setFromInt(0)


        BISTMessageIgnored = register_class.cForceSetDMTerminator( self,  { 'name' : 'BIST Message Ignored',
                                                                'offset' : 18,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(BISTMessageIgnored)
        BISTMessageIgnored.setFromInt(0)


        GotoMinReceived = register_class.cForceSetDMTerminator( self,  { 'name' : 'GotoMin Received',
                                                                'offset' : 19,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(GotoMinReceived)
        GotoMinReceived.setFromInt(0)


        UsbHostPresent = register_class.cForceSetDMTerminator( self,  { 'name' : 'USB Host Present',
                                                                'offset' : 20,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(UsbHostPresent)
        UsbHostPresent.setFromInt(0)


        UsbHostPresentNoLonger = register_class.cForceSetDMTerminator( self,  { 'name' : 'USB Host Present No Longer',
                                                                'offset' : 21,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(UsbHostPresentNoLonger)
        UsbHostPresentNoLonger.setFromInt(0)


        HighVoltageWarning = register_class.cForceSetDMTerminator( self,  { 'name' : 'High Voltage Warning',
                                                                'offset' : 22,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(HighVoltageWarning)
        HighVoltageWarning.setFromInt(0)


        PPswitchChanged = register_class.cForceSetDMTerminator( self,  { 'name' : 'Power Path Switch Changed',
                                                                'offset' : 23,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(PPswitchChanged)
        PPswitchChanged.setFromInt(0)


        PowerStatusUpdate = register_class.cForceSetDMTerminator( self,  { 'name' : 'Power Status Update',
                                                                'offset' : 24,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(PowerStatusUpdate)
        PowerStatusUpdate.setFromInt(0)


        DataStatusUpdate = register_class.cForceSetDMTerminator( self,  { 'name' : 'Data Status Update',
                                                                'offset' : 25,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        self.dataModel.addChild(DataStatusUpdate)
        DataStatusUpdate.setFromInt(1)


        StatusUpdate = register_class.cForceSetDMTerminator( self,  { 'name' : 'Status Update',
                                                                'offset' : 26,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(StatusUpdate)
        StatusUpdate.setFromInt(0)


        PDStatusUpdate = register_class.cForceSetDMTerminator( self,  { 'name' : 'PD Status Update',
                                                                'offset' : 27,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(PDStatusUpdate)
        PDStatusUpdate.setFromInt(0)


        ADCLowThreshold = register_class.cForceSetDMTerminator( self,  { 'name' : 'ADC Low Threshold',
                                                                'offset' : 28,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(ADCLowThreshold)
        ADCLowThreshold.setFromInt(0)


        ADCHighThreshold = register_class.cForceSetDMTerminator( self,  { 'name' : 'ADC High Threshold',
                                                                'offset' : 29,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(ADCHighThreshold)
        ADCHighThreshold.setFromInt(0)

        Cmd1Complete = register_class.cForceSetDMTerminator( self,  { 'name' : 'CMD1 Complete',
                                                                'offset' : 30,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Cmd1Complete)
        Cmd1Complete.setFromInt(0)


        Cmd2Complete = register_class.cForceSetDMTerminator( self,  { 'name' : 'CMD2 Complete',
                                                                'offset' : 31,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Cmd2Complete)
        Cmd2Complete.setFromInt(0)

        Error_DeviceIncompatible = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Device Incompatible',
                                                                'offset' : 32,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_DeviceIncompatible)
        Error_DeviceIncompatible.setFromInt(0)

        Error_CannotProvideVoltageOrCurrent = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Cannot Provide Voltage or Current',
                                                                'offset' : 33,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_CannotProvideVoltageOrCurrent)
        Error_CannotProvideVoltageOrCurrent.setFromInt(0)


        Error_CanProvideVoltageOrCurrentLater = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Cannot Provide Voltage or Current Later',
                                                                'offset' : 34,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_CanProvideVoltageOrCurrentLater)
        Error_CanProvideVoltageOrCurrentLater.setFromInt(0)

        Error_PowerEventOccurred = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Power Event Occurred',
                                                                'offset' : 35,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_PowerEventOccurred)
        Error_PowerEventOccurred.setFromInt(0)

        Error_MissingGetCapMessage = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Missing Get Capabilities Message',
                                                                'offset' : 36,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_MissingGetCapMessage)
        Error_MissingGetCapMessage.setFromInt(0)

        Error_ProtocolError = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Protocol Error',
                                                                'offset' : 38,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_ProtocolError)
        Error_ProtocolError.setFromInt(0)

        Error_MessageData = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Message Data',
                                                                'offset' : 39,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_MessageData)
        Error_MessageData.setFromInt(0)

        Error_DischargeFailed = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Discharge Failed',
                                                                'offset' : 41,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_DischargeFailed)
        Error_DischargeFailed.setFromInt(0)

        SnkTransitionComplete = register_class.cForceSetDMTerminator( self,  { 'name' : 'Sink Transition Complete',
                                                                'offset' : 42,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(SnkTransitionComplete)
        SnkTransitionComplete.setFromInt(0)

        Error_UnableToSource = register_class.cForceSetDMTerminator( self,  { 'name' : 'Error: Unable to Source',
                                                                'offset' : 46,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(Error_UnableToSource)
        Error_UnableToSource.setFromInt(0)

        UserSvidModeEntered = register_class.cForceSetDMTerminator( self,  { 'name' : 'User SVID Mode Entered',
                                                                'offset' : 56,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(UserSvidModeEntered)
        UserSvidModeEntered.setFromInt(0)

        UserSvidModeExited = register_class.cForceSetDMTerminator( self,  { 'name' : 'User SVID Mode Exited',
                                                                'offset' : 57,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(UserSvidModeExited)
        UserSvidModeExited.setFromInt(0)

        UserSvidAttentionVDMReceived = register_class.cForceSetDMTerminator( self,  { 'name' : 'User SVID Attention VDM Received',
                                                                'offset' : 58,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(UserSvidAttentionVDMReceived)
        UserSvidAttentionVDMReceived.setFromInt(0)

        UserSvidOtherVDMReceived = register_class.cForceSetDMTerminator( self,  { 'name' : 'User SVID Other VDM Received',
                                                                'offset' : 59,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(UserSvidOtherVDMReceived)
        UserSvidOtherVDMReceived.setFromInt(0)


class cStatus_0x1A_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Status',
                                                 'address' : 0x1A,
                                                 'byte length' : 6,
                                                 'permission' : 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Status',
                                                        'offset' : 0,
                                                        'bit length' : 48 })

        plugPresent = register_class.cListDMTerminator(self,
                                                                    {'name' : 'Plug Present',
                                                                     'offset' : 0,
                                                                     'bit length' : 1 })

        plugPresent.setReportList(['No plug present', 'Plug present, see Conn State (below) for details.'])
        plugPresent.help = """Indicates presence of plug"""
        self.dataModel.addChild(plugPresent)

        connState = register_class.cListDMTerminator(self,
                                                                    {'name' : 'Conn State',
                                                                     'offset' : 1,
                                                                     'bit length' : 3 })

        connState.setReportList(['No connection', 'Port is disabled', 'Audio connection (Ra/Ra)', 'Debug connection (Rd/Rd)', \
                                 'No connection, Ra detected (Ra but no Rd)', 'Reserved (may be used for Rp/Rp Debug connection)', \
                                 'Connection present, no Ra detected (Rd but no Ra) or Rp detected with no previous Ra detection, includes PD Controller that connected in Attached.SNK.', \
                                 'Connection present, Ra detected (Rd and Ra detected) or Rp detected with previous Ra detection (assumes PD Controller started as Source and later swapped to Sink).'])
        connState.help = """Indicates state of connection"""
        self.dataModel.addChild(connState)

        plugOrientation = register_class.cListDMTerminator(self,
                                                                    {'name' : 'Plug Orientation',
                                                                     'offset' : 4,
                                                                     'bit length' : 1 })

        plugOrientation.setReportList(['Upside-up orientation (plug CC on C_CC1) or orientation unknown or port is disabled/disconnected.', \
                                       'Upside-down orientation (plug CC on C_CC2).'])
        plugOrientation.help = """Indicates port orientation when known (requires connection)."""
        self.dataModel.addChild(plugOrientation)

        portRole = register_class.cListDMTerminator(self,
                                                                    {'name' : 'Port Role',
                                                                     'offset' : 5,
                                                                     'bit length' : 1 })
        portRole.setReportList(['PD Controller is Sink (C_CCx pull-down active) or port is disabled/disconnected.', \
                                'PD Controller is Source (C_CCx pull-up active).'])
        portRole.help = """Indicates current state of PD Controller C_CCx pulls, and therefore PD Controller Power Role, once connected. This bit does not toggle during Unattached.* state transitions."""
        self.dataModel.addChild(portRole)


        dataRole = register_class.cListDMTerminator(self,
                                                                    {'name' : 'Data Role',
                                                                     'offset' : 6,
                                                                     'bit length' : 1 })
        dataRole.setReportList(['PD Controller is UFP or port is disabled/disconnected.', 'PD Controller is DFP.'])
        dataRole.help = """Indicates current state of PD Controller Data Role once connected."""
        self.dataModel.addChild(dataRole)

        vconnEn = register_class.cListDMTerminator(self,
                                                                    {'name' : 'VConn Enabled',
                                                                     'offset' : 7,
                                                                     'bit length' : 1 })
        vconnEn.setReportList(['VConn not supplied by this controller', 'VConn is supplied by this controller'])
        vconnEn.help = """Indicates whether this PD controller is supplying VConn power to the cable"""
        self.dataModel.addChild(vconnEn)

        ppSwitchList = ['Disabled', 'Disabled due to Overcurrent', 'Enabled Reverse current from VBUS to Power Path blocked (acting as output)', 'Enabled Reverse current from Power Path to VBUS blocked (acting as input)']


        pp5v = register_class.cListDMTerminator(self,
                                                                    {'name' : 'PP_5V Switch',
                                                                     'offset' : 8,
                                                                     'bit length' : 2 })
        pp5v.setReportList(ppSwitchList)
        pp5v.help = """Indicates whether this power path switch is enabled and whether reverse current protection is enabled and in which direction."""
        self.dataModel.addChild(pp5v)

        ppHv = register_class.cListDMTerminator(self,
                                                                    {'name' : 'PP_HV Switch',
                                                                     'offset' : 10,
                                                                     'bit length' : 2 })
        ppHv.setReportList(ppSwitchList)
        ppHv.help = """Indicates whether this power path switch is enabled and whether reverse current protection is enabled and in which direction."""
        self.dataModel.addChild(ppHv)

        ppHve = register_class.cListDMTerminator(self,
                                                                    {'name' : 'PP_HVE Switch',
                                                                     'offset' : 12,
                                                                     'bit length' : 2 })
        ppHve.setReportList(ppSwitchList)
        ppHve.help = """Indicates whether this power path switch is enabled and whether reverse current protection is enabled and in which direction."""
        self.dataModel.addChild(ppHve)

        ppCablelist = ['Disabled', 'Disabled due to Overcurrent', 'PP_CABLE enabled on C_CC1', 'PP_CABLE enabled on C_CC2' ]

        ppCable = register_class.cListDMTerminator(self,
                                                                    {'name' : 'PP_Cable Switch',
                                                                     'offset' : 14,
                                                                     'bit length' : 2 })
        ppCable.setReportList(ppCablelist)
        ppCable.help = """Indicates whether the PP_Cable (VConn) power path switch is enabled and on which configuration channel (cc)."""
        self.dataModel.addChild(ppCable)

        overCurr = register_class.cBooleanDMTerminator(self,
                                                                    {'name' : 'Overcurrent',
                                                                     'offset' : 16,
                                                                     'bit length' : 1 })
        overCurr.setReportList(['VConn not supplied by this controller', 'VConn is supplied by this controller'])
        overCurr.help = """Indicates whether an overcurrent event has been detected"""
        self.dataModel.addChild(overCurr)


        powSourceList = ['Unknown', 'VIN_3V3', 'PP_Cable', 'VBus' ]

        powSource = register_class.cListDMTerminator(self,
                                                                    {'name' : 'Power Source',
                                                                     'offset' : 18,
                                                                     'bit length' : 2 })
        powSource.setReportList(powSourceList)
        powSource.help = """Indicates whether the PD controller is being supplied from VIN_3V3, PP_Cable or VBus."""
        self.dataModel.addChild(powSource)


        vbusStatus = register_class.cListDMTerminator(self,
                                                    {'name' : 'VBUS Status',
                                                     'offset' : 20,
                                                     'bit length' : 2 })
        vbusStatus.setReportList(['VBUS is at vSafe0V (less than 0.8V)', \
                                  'VBUS is at vSafe5V (4.75V to 5.5V). See ADC Results for exact voltage provided multichannel ADC is active.',  \
                                  'VBUS is at other PD-negotiated power level and within expected limits. See ADC Results for exact voltage provided multi-channel ADC is active.', \
                                  'VBUS is not within any of the above ranges. See ADC Results for exact voltage provided multi-channel ADC is active.' ])
        vbusStatus.help = """Indicates status of VBUS."""
        self.dataModel.addChild(vbusStatus)

        usbHostPresent = register_class.cListDMTerminator(self,
                                                    {'name' : 'USB Host Present',
                                                     'offset' : 22,
                                                     'bit length' : 2 })
        usbHostPresent.setReportList(['No far-end device present providing VBUS or PD Controller power role is Source.', \
                                  'VBUS is being provided by a far-end device that is a PD device not capable of USB communications', \
                                  'VBUS is being provided by a far-end device that is not a PD device.', \
                                  'VBUS is being provided by a far-end device that is a PD device capable of USB communications.'])
        usbHostPresent.help = """Indicates presence of USB Host"""
        self.dataModel.addChild(usbHostPresent)

        actingAsLegacy = register_class.cListDMTerminator(self,
                                                    {'name' : 'Acting as Legacy',
                                                     'offset' : 24,
                                                     'bit length' : 2 })
        actingAsLegacy.setReportList(['PD Controller is not in a legacy (non PD mode).', \
                                      'PD Controller is acting like a legacy sink. It will not respond to USB PD message traffic.', \
                                      'PD Controller is acting like a legacy source. It will not respond to USB PD message traffic.'])
        actingAsLegacy.setMaxValue(3)
        actingAsLegacy.help = """Indicates when PD Controller has gone into a mode where it is acting like a legacy (non PD) device."""
        self.dataModel.addChild(actingAsLegacy)

        goToMinActive = register_class.cListDMTerminator(self,
                                                    {'name' : 'Go To Min Active',
                                                     'offset' : 26,
                                                     'bit length' : 1 })
        goToMinActive.setReportList(['No PD contract established or GotoMin restriction has been cleared by Source Capabilities message or disconnect/Hard Reset.', \
                                     'GotoMin has been received as Sink or sent as Source'])
        goToMinActive.help = """Indicates whether GoToMin has been received"""
        self.dataModel.addChild(goToMinActive)

        bist = register_class.cListDMTerminator(self,
                                                    {'name' : 'BIST',
                                                     'offset' : 27,
                                                     'bit length' : 1 })
        bist.setReportList(['No BIST in progress','BIST in progress'])
        bist.help = """Indicates status of BIST"""
        self.dataModel.addChild(bist)

        HVWarn = register_class.cListDMTerminator(self,
                                                    {'name' : 'High Voltage Warning',
                                                     'offset' : 28,
                                                     'bit length' : 1 })
        HVWarn.setReportList(['PD Controller operating as Sink or VBUS voltage is below limit specified by HighVoltageWarningLimit register or port is disconnected.', \
                              'PD Controller operating as Source and VBUS voltage is above limit specified by HighVoltageWarningLimit register.'])
        HVWarn.help = """Indicates if HighVoltageWarning Limit is triggered"""
        self.dataModel.addChild(HVWarn)

        LVWarn = register_class.cListDMTerminator(self,
                                                    {'name' : 'Low Voltage Warning',
                                                     'offset' : 29,
                                                     'bit length' : 1 })
        LVWarn.setReportList(['PD Controller operating as Sink or VBUS voltage is above limit specified by LowVoltageWarningLimit register or port is disconnected.', \
                              'PD Controller operating as Source and VBUS voltage is below limit specified by LowVoltageWarningLimit register.'])
        LVWarn.help = """Indicates if LowVoltageWarning Limit is triggered"""
        self.dataModel.addChild(LVWarn)


class cSystemPowerState_0x20_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'System Power State',
                                                 'address' : 0x20,
                                                 'byte length' : 1,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'System Power State',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        sysPowReportDict = { 0 : 'Do Not Sleep', 3 : 'Sleep, I2C Remains Active', 5 : 'Sleep, I2C Looses First Transaction' }
        sysPowReplaceDict = { 1:0, 2:0, 4:5}

        sysPowState = register_class.cDictDMTerminator(self,
                                        {'name' : 'Sleep Mode (When Allowed)',
                                         'offset' : 0,
                                         'bit length' : 3 })

        sysPowState.setReportDict(sysPowReportDict)
        sysPowState.setReplaceDict(sysPowReplaceDict)

        self.dataModel.addChild(sysPowState)




class cSysConfig_0x28_register(register_class.cRegister) :
    def __init__(self):
        self.FIXED_STRING_INDICES = True

        register_class.cRegister.__init__(self, {'register name' : 'System Configuration',
                                                 'address' : 0x28,
                                                 'byte length' : 18,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'System Configuration',
                                                         'offset' : 0,
                                                         'bit length' : 144 })


        portInfoReportDict = { 2 : 'UFP', 4 : 'DFP', 5 : 'DRP', 7 : 'Disabled' }
        portInfoReplaceDict = { 0:2, 1:2, 3:5, 6:4 }

        PortInfo = register_class.cDictDMTerminator(self,
                                        {'name' : 'Port Information',
                                         'offset' : 0,
                                         'bit length' : 3 })

        PortInfo.setReportDict(portInfoReportDict)
        PortInfo.setReplaceDict(portInfoReplaceDict)

        self.dataModel.addChild(PortInfo)

        ReceptType = register_class.cForceSetDMTerminator( self,  { 'name' : 'Voltage',
                                                                'offset' : 3,
                                                                'bit length' : 3,
                                                                'force value' : int(1),
                                                                'force display' : 'Standard fully-featured USB-C receptacle'})

        self.dataModel.addChild(ReceptType)
        ReceptType.setFromInt(1)
        if hide_simplified :
            ReceptType.hide()

        TypeCCurr = register_class.cForceSetDMTerminator( self,  { 'name' : 'Type-C Current',
                                                                'offset' : 6,
                                                                'bit length' : 2,
                                                                'force value' : int(0),
                                                                'force display' : 'Default Current (weakest pullup)'})

        self.dataModel.addChild(TypeCCurr)
        TypeCCurr.setFromInt(0)
        if hide_simplified :
            TypeCCurr.hide()


        TypeCPeak = register_class.cForceSetDMTerminator( self,  { 'name' : 'Type-C Current OCP Peak Current',
                                                                'offset' : 10,
                                                                'bit length' : 2,
                                                                'force value' : int(0),
                                                                'force display' : '100%'})

        self.dataModel.addChild(TypeCPeak)
        TypeCPeak.setFromInt(0)
        if hide_simplified :
            TypeCPeak.hide()


        VConnSupp = register_class.cForceSetDMTerminator( self,  { 'name' : 'V_CONN Supported',
                                                                'offset' : 8,
                                                                'bit length' : 2,
                                                                'force value' : int(3),
                                                                'force display' : 'VCONN supported as DFP/UFP (accept VCONN_Swap requests)'})

        self.dataModel.addChild(VConnSupp)
        VConnSupp.setFromInt(3)
        if hide_simplified :
            VConnSupp.hide()

        HVWarn = register_class.cForceSetDMTerminator( self,  { 'name' : 'High Voltage Warning Level',
                                                                'offset' : 14,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Warning when source VBUS voltage exceeds 20% from nominal'})

        self.dataModel.addChild(HVWarn)
        HVWarn.setFromInt(1)
        if hide_simplified :
            HVWarn.hide()

        LVWarn = register_class.cForceSetDMTerminator( self,  { 'name' : 'Low Voltage Warning Level',
                                                                'offset' : 15,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Warning when source VBUS Voltage dips below 20% from nominal'})

        self.dataModel.addChild(LVWarn)
        LVWarn.setFromInt(1)
        if hide_simplified :
            LVWarn.hide()

        OVPtrip = register_class.cForceSetDMTerminator( self,  { 'name' : 'Over Voltage Protection Trip Point',
                                                                'offset' : 16,
                                                                'bit length' : 6,
                                                                'force value' : int(0x3F),
                                                                'force display' : '24 V'})

        self.dataModel.addChild(OVPtrip)
        OVPtrip.setFromInt(0x3F)
        if hide_simplified :
            OVPtrip.hide()

        OVPUsage = register_class.cForceSetDMTerminator( self,  { 'name' : 'Over Voltage Protection Trip Point',
                                                                'offset' : 22,
                                                                'bit length' : 2,
                                                                'force value' : int(0x3),
                                                                'force display' : 'Disconnect VBUS if voltage exceeds 15% of expected max.'})

        self.dataModel.addChild(OVPUsage)
        OVPUsage.setFromInt(0x3)
        if hide_simplified :
            OVPUsage.hide()


        PP5VConf = register_class.cListDMTerminator(self,
                                                                    {'name' : 'PP_5V0 Configuration',
                                                                     'offset' : 24,
                                                                     'bit length' : 2 })
        PP5VConf.setMaxValue(1)
        PP5VConf.setReportList(['PP_5V0 switch not used (disabled)', \
                                'PP_5V0 switch configured for output', \
                                ])

        self.dataModel.addChild(PP5VConf)

        PPHVConf = register_class.cListDMTerminator(self,
                                                                    {'name' : 'PP_HV Configuration',
                                                                     'offset' : 26,
                                                                     'bit length' : 2 })

        PPHVConf.setReportList(['PP_HV switch not used (disabled)', \
                                'PP_HV switch configured for output', \
                                'PP_HV switch configured for input', \
                                'PP_HV switch configured for input, wait for SYS_RDY command', \
                                ])

        self.dataModel.addChild(PPHVConf)

        PPExtConf = register_class.cListDMTerminator(self,
                                                                    {'name' : 'PP_EXT Configuration',
                                                                     'offset' : 28,
                                                                     'bit length' : 3 })

        PPExtConf.setMaxValue(5)
        PPExtConf.setReportList(['PP_EXT not used (disabled)', \
                                 'PP_EXT configured for output', \
                                 'PP_EXT configured for input', \
                                 'PP_EXT configured for input, wait for SYS_RDY command', \
                                 'PP_EXT configured for input and output', \
                                 'PP_EXT configured for input and output, wait for SYS_RDY command', \
                                 ])

        self.dataModel.addChild(PPExtConf)

        BC12Enable = register_class.cForceSetDMTerminator( self,  { 'name' : 'BC 1.2 Enable',
                                                                'offset' : 32,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        self.dataModel.addChild(BC12Enable)
        BC12Enable.setFromInt(1)
        if hide_simplified :
            BC12Enable.hide()

        USBRPEn = register_class.cBooleanDMTerminator(self,
                                                                    {'name' : 'USB RP Enable',
                                                                     'offset' : 33,
                                                                     'bit length' : 1 })

        self.dataModel.addChild(USBRPEn)


        USBEPEn = register_class.cForceSetDMTerminator( self,  { 'name' : 'USB EP Enable',
                                                                'offset' : 34,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        self.dataModel.addChild(USBEPEn)
        USBEPEn.setFromInt(1)
        if hide_simplified :
            USBEPEn.hide()


        USB3Rate = register_class.cListDMTerminator(self,
                                                                    {'name' : 'USB3.0/3.1 Rate',
                                                                     'offset' : 35,
                                                                     'bit length' : 2 })
        USB3Rate.setMaxValue(2)
        USB3Rate.setReportList(['USB3 not supported', \
                                'USB3 Gen1 signaling rate supported', \
                                'USB3 Gen2 signaling rate supported', \
                                ])

        self.dataModel.addChild(USB3Rate)

        USB2Supp = register_class.cBooleanDMTerminator(self,
                                                                    {'name' : 'USB2.0 Supported',
                                                                     'offset' : 37,
                                                                     'bit length' : 1 })

        self.dataModel.addChild(USB2Supp)

        AudAccSupp = register_class.cForceSetDMTerminator( self,  { 'name' : 'Audio Accessory Support',
                                                                'offset' : 38,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        self.dataModel.addChild(AudAccSupp)
        AudAccSupp.setFromInt(1)
        if hide_simplified :
            AudAccSupp.hide()


        DbgAccSupp = register_class.cForceSetDMTerminator( self,  { 'name' : 'Debug Accessory Support',
                                                                'offset' : 39,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        self.dataModel.addChild(DbgAccSupp)
        DbgAccSupp.setFromInt(1)
        if hide_simplified :
            DbgAccSupp.hide()


        PowAccSupp = register_class.cForceSetDMTerminator( self,  { 'name' : 'Power Accessory Support',
                                                                'offset' : 40,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(PowAccSupp)
        PowAccSupp.setFromInt(0)
        if hide_simplified :
            PowAccSupp.hide()

        RSense = register_class.cListDMTerminator(self,
                                                                    {'name' : 'Rsense (External Sense Resistor)',
                                                                     'offset' : 41,
                                                                     'bit length' : 1 })

        RSense.setReportList(['10 mOhm', \
                                '5 mOhm' ])

        self.dataModel.addChild(RSense)

        TrySrc = register_class.cForceSetDMTerminator( self,  { 'name' : 'Try.Src (Try Source Support)',
                                                                'offset' : 42,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(TrySrc)
        TrySrc.setFromInt(0)
        if hide_simplified :
            TrySrc.hide()


        Billboard = register_class.cForceSetDMTerminator( self,  { 'name' : 'USB2.0 Endpoint Billboard Enable',
                                                                'offset' : 43,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        self.dataModel.addChild(Billboard)
        Billboard.setFromInt(1)
        if hide_simplified :
            Billboard.hide()


        PPExtOctEnable = register_class.cForceSetDMTerminator( self,  { 'name' : 'External Power Path Over-Current Timeout Enable',
                                                                'offset' : 50,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        self.dataModel.addChild(PPExtOctEnable)
        PPExtOctEnable.setFromInt(1)
        if hide_simplified :
            PPExtOctEnable.hide()

        PPExtOct = register_class.cForceSetDMTerminator( self,  { 'name' : 'External Power Path Over-current Timeout',
                                                                'offset' : 46,
                                                                'bit length' : 4,
                                                                'force value' : int(4),
                                                                'force display' : '640 us'})


        self.dataModel.addChild(PPExtOct)
        PPExtOct.setFromInt(4)
        if hide_simplified :
            PPExtOct.hide()

        ResetZTOCount = register_class.cForceSetDMTerminator( self,  { 'name' : 'Reset Z Timeout Count',
                                                                'offset' : 51,
                                                                'bit length' : 6,
                                                                'force value' : int(2),
                                                                'force display' : '2'})

        self.dataModel.addChild(ResetZTOCount)
        ResetZTOCount.setFromInt(2)
        if hide_simplified :
            ResetZTOCount.hide()


        ResetZTOClock = register_class.cForceSetDMTerminator( self,  { 'name' : 'Reset Z Timeout Clock',
                                                                'offset' : 57,
                                                                'bit length' : 2,
                                                                'force value' : int(1),
                                                                'force display' : '640 uS'})

        self.dataModel.addChild(ResetZTOClock)
        ResetZTOClock.setFromInt(2)
        if hide_simplified :
            ResetZTOClock.hide()


        Vout3v3thresh = register_class.cForceSetDMTerminator( self,  { 'name' : 'Sense Disconnect on CC (in addition to VBUS) when Sink',
                                                                'offset' : 59,
                                                                'bit length' : 3,
                                                                'force value' : int(5),
                                                                'force display' : '2.75 V'})

        self.dataModel.addChild(Vout3v3thresh)
        Vout3v3thresh.setFromInt(5)
        if hide_simplified :
            Vout3v3thresh.hide()


        Vout3v3enable = register_class.cForceSetDMTerminator( self,  { 'name' : 'Vout3V3 (3.3 V output) enable',
                                                                'offset' : 62,
                                                                'bit length' : 1,
                                                                'force value' : 1,
                                                                'force display' : 'Enabled'})

        self.dataModel.addChild(Vout3v3enable)
        Vout3v3enable.setFromInt(1)
        if hide_simplified :
            Vout3v3enable.hide()




        ccDisconnectSink = register_class.cForceSetDMTerminator( self,  { 'name' : 'Sense Disconnect on CC (in addition to VBUS) when Sink',
                                                                'offset' : 64,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(ccDisconnectSink)
        ccDisconnectSink.setFromInt(0)
        if hide_simplified :
            ccDisconnectSink.hide()


        setUvpTo4P5 = register_class.cForceSetDMTerminator( self,  { 'name' : 'Set Under-voltage Protection to 4.5V always',
                                                                'offset' : 66,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(setUvpTo4P5)
        setUvpTo4P5.setFromInt(0)
        if hide_simplified :
            setUvpTo4P5.hide()


        UvpTripPoint5V = register_class.cForceSetDMTerminator( self,  { 'name' : 'Under-voltage Protection Trip Point, PP_5V',
                                                                'offset' : 67,
                                                                'bit length' : 3,
                                                                'force value' : int(3),
                                                                'force display' : '20%'})

        self.dataModel.addChild(UvpTripPoint5V)
        UvpTripPoint5V.setFromInt(1)
        if hide_simplified :
            UvpTripPoint5V.hide()



        UvpUsageHV = register_class.cForceSetDMTerminator( self,  { 'name' : 'Under-voltage Protection Usage, PP_HV',
                                                                'offset' : 70,
                                                                'bit length' : 3,
                                                                'force value' : int(3),
                                                                'force display' : '20%'})

        self.dataModel.addChild(UvpUsageHV)
        UvpUsageHV.setFromInt(1)
        if hide_simplified :
            UvpUsageHV.hide()


        idealDiodeRCP = register_class.cForceSetDMTerminator(self,
                                                                    {'name' : 'Reverse-current Protection Scheme',
                                                                     'offset' : 77,
                                                                     'bit length' : 1,
                                                                    'force value' : int(1),
                                                                    'force display' : 'Ideal Diode'})

        if hide_simplified :
            idealDiodeRCP.hide()
        self.dataModel.addChild(idealDiodeRCP)
        idealDiodeRCP.setFromInt(1)

        legacyRCP = register_class.cForceSetDMTerminator(self,
                                                                    {'name' : 'Use Legacy RCP Scheme',
                                                                     'offset' : 78,
                                                                     'bit length' : 1,
                                                                    'force value' : int(0),
                                                                    'force display' : 'Do not use Legacy RCP'})

        legacyRCP.hide()
        self.dataModel.addChild(legacyRCP)
        legacyRCP.setFromInt(0)

        UARTDis = register_class.cForceSetDMTerminator( self,  { 'name' : 'UART Disable',
                                                                'offset' : 79,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Enabled (0)'})

        UARTDis.hide()
        self.dataModel.addChild(UARTDis)
        UARTDis.setFromInt(0)

        serStrIndex = register_class.cForceSetDMTerminator( self,  { 'name' : 'Serial String Index',
                                                                'offset' : 80,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Serial Number String at Index 1'})


        self.dataModel.addChild(serStrIndex)
        serStrIndex.setFromInt(1)
        if hide_simplified :
            serStrIndex.hide()

        prodStrIndex = register_class.cForceSetDMTerminator( self,  { 'name' : 'Product String Index',
                                                                'offset' : 81,
                                                                'bit length' : 2,
                                                                'force value' : int(2),
                                                                'force display' : 'Product String at Index 2'})

        self.dataModel.addChild(prodStrIndex)
        prodStrIndex.setFromInt(2)
        if hide_simplified :
            prodStrIndex.hide()

        manufactStrIndex = register_class.cForceSetDMTerminator( self,  { 'name' : 'Manufacturer String Index',
                                                                'offset' : 83,
                                                                'bit length' : 2,
                                                                'force value' : int(3),
                                                                'force display' : 'Manufacturer String at Index 3'})

        self.dataModel.addChild(manufactStrIndex)
        manufactStrIndex.setFromInt(3)
        if hide_simplified :
            manufactStrIndex.hide()

        billboardURLStrIndex = register_class.cForceSetDMTerminator( self,  { 'name' : 'Billboard URL String Index',
                                                                'offset' : 85,
                                                                'bit length' : 3,
                                                                'force value' : int(4),
                                                                'force display' : 'Billboard URL String at Index 4'})

        self.dataModel.addChild(billboardURLStrIndex)
        billboardURLStrIndex.setFromInt(4)
        if hide_simplified :
            billboardURLStrIndex.hide()

        intTBTStrIndex = register_class.cForceSetDMTerminator( self,  { 'name' : 'Intel Thuderbolt Billboard String Index',
                                                                'offset' : 88,
                                                                'bit length' : 4,
                                                                'force value' : int(5),
                                                                'force display' : 'TBT Billboard String at Index 5'})

        self.dataModel.addChild(intTBTStrIndex)
        intTBTStrIndex.setFromInt(5)
        if hide_simplified :
            intTBTStrIndex.hide()

        displayPortStrIndex = register_class.cForceSetDMTerminator( self,  { 'name' : 'DisplayPort Billboard String Index',
                                                                'offset' : 96,
                                                                'bit length' : 4,
                                                                'force value' : int(6),
                                                                'force display' : 'DisplayPort Billboard String at Index 6'})

        self.dataModel.addChild(displayPortStrIndex)
        displayPortStrIndex.setFromInt(6)
        if hide_simplified :
            displayPortStrIndex.hide()

        cust1VidStrIndex = register_class.cForceSetDMTerminator( self,  { 'name' : 'Custom Vendor ID 1 String Index',
                                                                'offset' : 104,
                                                                'bit length' : 4,
                                                                'force value' : int(0),
                                                                'force display' : 'No Custom Vendor ID 1 Billboard String'})

        self.dataModel.addChild(cust1VidStrIndex)
        cust1VidStrIndex.setFromInt(0)
        if hide_simplified :
            cust1VidStrIndex.hide()

        cust2VidStrIndex = register_class.cForceSetDMTerminator( self,  { 'name' : 'Custom Vendor ID 2 String Index',
                                                                'offset' : 108,
                                                                'bit length' : 4,
                                                                'force value' : int(0),
                                                                'force display' : 'No Custom Vendor ID 2 Billboard String'})

        self.dataModel.addChild(cust2VidStrIndex)
        cust2VidStrIndex.setFromInt(0)
        if hide_simplified :
            cust2VidStrIndex.hide()

        cust3VidStrIndex = register_class.cForceSetDMTerminator( self,  { 'name' : 'Custom Vendor ID 3 String Index',
                                                                'offset' : 112,
                                                                'bit length' : 4,
                                                                'force value' : int(0),
                                                                'force display' : 'No Custom Vendor ID 3 Billboard String'})

        self.dataModel.addChild(cust3VidStrIndex)
        cust3VidStrIndex.setFromInt(0)
        if hide_simplified :
            cust3VidStrIndex.hide()

        cust4VidStrIndex = register_class.cForceSetDMTerminator( self,  { 'name' : 'Custom Vendor ID 4 String Index',
                                                                'offset' : 116,
                                                                'bit length' : 4,
                                                                'force value' : int(0),
                                                                'force display' : 'No Custom Vendor ID 4 Billboard String'})

        self.dataModel.addChild(cust4VidStrIndex)
        cust4VidStrIndex.setFromInt(0)
        if hide_simplified :
            cust4VidStrIndex.hide()


        PP5vOctEnable = register_class.cForceSetDMTerminator( self,  { 'name' : 'Internal 5V Power Path Over-Current Timeout Enable',
                                                                'offset' : 124,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        self.dataModel.addChild(PP5vOctEnable)
        PP5vOctEnable.setFromInt(1)
        if hide_simplified :
            PP5vOctEnable.hide()

        PP5vOct = register_class.cForceSetDMTerminator( self,  { 'name' : 'Internal 5 Volt Power Path Over-current Timeout',
                                                                'offset' : 120,
                                                                'bit length' : 4,
                                                                'force value' : int(4),
                                                                'force display' : '640 us'})

        self.dataModel.addChild(PP5vOct)
        PP5vOct.setFromInt(4)
        if hide_simplified :
            PP5vOct.hide()

        PPHvOctEnable = register_class.cForceSetDMTerminator( self,  { 'name' : 'Internal HV Power Path Over-Current Timeout Enable',
                                                                'offset' : 132,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        self.dataModel.addChild(PPHvOctEnable)
        PPHvOctEnable.setFromInt(1)
        if hide_simplified :
            PPHvOctEnable.hide()

        PPHvOct = register_class.cForceSetDMTerminator( self,  { 'name' : 'Internal High-Voltage Power Path Over-current Timeout',
                                                                'offset' : 128,
                                                                'bit length' : 4,
                                                                'force value' : int(4),
                                                                'force display' : '640 us'})

        self.dataModel.addChild(PPHvOct)
        PPHvOct.setFromInt(4)
        if hide_simplified :
            PPHvOct.hide()

        self.dataModel.addChild(PPHvOct)


        gpioThresh = register_class.cForceSetDMTerminator( self,  { 'name' : 'Voltage Threshold for Adjustable GPIO Event',
                                                                'offset' : 136,
                                                                'bit length' : 8,
                                                                'force value' : int(120),
                                                                'force display' : '12 V'})

        self.dataModel.addChild(gpioThresh)
        gpioThresh.setFromInt(4)
        if hide_simplified :
            gpioThresh.hide()


        self.dataModel.addChild(gpioThresh)



# four arguments:
# [0] process swap to sink
# [1] initiate swap to sink
# [2] process swap to source
# [3] initiate swap to source
def powSwapDerivedFxn(argumentList) :
    procSink = argumentList[0].valueToInt()
    initSink = argumentList[1].valueToInt()
    procSource = argumentList[2].valueToInt()
    initSource = argumentList[3].valueToInt()

    # arg 0-3 (0 is lsb) -->
    # 'No Preference, Rejects All Swaps', 'No Preference, Supports All Swaps', 'Prefers Power Source', 'Prefers Power Sink'

    inputInt = (procSink & 0x1) | (initSink & 0x1) << 1 | (procSource & 0x1) << 2 | (initSource & 0x1) << 3

    translationDict = { 0b0000 : 0b00,
                        0b0001 : 0b00,
                        0b0010 : 0b11,
                        0b0011 : 0b11,
                        0b0100 : 0b00,
                        0b0101 : 0b01,
                        0b0110 : 0b00,
                        0b0111 : 0b11,
                        0b1000 : 0b10,
                        0b1001 : 0b10,
                        0b1010 : 0b00,
                        0b1011 : 0b11,
                        0b1100 : 0b10,
                        0b1101 : 0b10,
                        0b1110 : 0b00,
                        0b1111 : 0b00
                        }

    return translationDict[inputInt]

# four arguments:
# [0] process swap to sink
# [1] initiate swap to sink
# [2] process swap to source
# [3] initiate swap to source
def powSwapUpdateFxn(value, argumentList) :
    # 'No Preference, Rejects All Swaps', 'No Preference, Supports All Swaps', 'Prefers Power Source', 'Prefers Power Sink'
    # --> arg 0-3 (0 is lsb)
    revTranslationDict = { 0b00 : 0b0000,
                           0b01 : 0b0101,
                           0b10 : 0b1100,
                           0b11 : 0b0011
                           }

    outBits = revTranslationDict[value]

    argumentList[0].setFromInt(outBits & (0b0001))
    argumentList[1].setFromInt( (outBits & (0b0010)) >> 1 )
    argumentList[2].setFromInt( (outBits & (0b0100)) >> 2 )
    argumentList[3].setFromInt( (outBits & (0b1000)) >> 3 )


# four arguments:
# [0] process swap to UFP
# [1] initiate swap to UFP
# [2] process swap to DFP
# [3] initiate swap to DFP
def dataSwapDerivedFxn(argumentList) :
    procUFP = argumentList[0].valueToInt()
    initUFP = argumentList[1].valueToInt()
    procDFP = argumentList[2].valueToInt()
    initDFP = argumentList[3].valueToInt()

    # arg 0-3 (0 is lsb) -->
    # 'No Preference, Rejects All Swaps', 'No Preference, Supports All Swaps', 'Prefers Data DFP (host)', 'Prefers Data UFP (device)'

    inputInt = (procUFP & 0x1) | (initUFP & 0x1) << 1 | (procDFP & 0x1) << 2 | (initDFP & 0x1) << 3

    translationDict = { 0b0000 : 0b00,
                        0b0001 : 0b00,
                        0b0010 : 0b11,
                        0b0011 : 0b11,
                        0b0100 : 0b00,
                        0b0101 : 0b01,
                        0b0110 : 0b00,
                        0b0111 : 0b11,
                        0b1000 : 0b10,
                        0b1001 : 0b10,
                        0b1010 : 0b00,
                        0b1011 : 0b11,
                        0b1100 : 0b10,
                        0b1101 : 0b10,
                        0b1110 : 0b00,
                        0b1111 : 0b00
                        }

    return translationDict[inputInt]

# four arguments:
# [0] process swap to sink
# [1] initiate swap to sink
# [2] process swap to source
# [3] initiate swap to source
def dataSwapUpdateFxn(value, argumentList) :
    # 'No Preference, Rejects All Swaps', 'No Preference, Supports All Swaps', 'Prefers Data DFP (host)', 'Prefers Data UFP (device)'
    # --> arg 0-3 (0 is lsb)
    revTranslationDict = { 0b00 : 0b0000,
                           0b01 : 0b0101,
                           0b10 : 0b1100,
                           0b11 : 0b0011
                           }

    outBits = revTranslationDict[value]

    argumentList[0].setFromInt(outBits & (0b0001))
    argumentList[1].setFromInt( (outBits & (0b0010)) >> 1 )
    argumentList[2].setFromInt( (outBits & (0b0100)) >> 2 )
    argumentList[3].setFromInt( (outBits & (0b1000)) >> 3 )


class cControlConfig_0x29_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Control Configuration',
                                                 'address' : 0x29,
                                                 'byte length' : 5,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Control Configuration',
                                                         'offset' : 0,
                                                         'bit length' : 40 })


        disablePD = register_class.cForceSetDMTerminator( self,  { 'name' : 'PD Mode',
                                                                'offset' : 0,
                                                                'bit length' : 2,
                                                                'force value' : int(0),
                                                                'force display' : 'Normal PD Behavior'})

        self.dataModel.addChild(disablePD)
        disablePD.setFromInt(0)
        if hide_simplified :
            disablePD.hide()


        externallyPowered = register_class.cBooleanDMTerminator(self,
                                                                    {'name' : 'Externally Powered',
                                                                     'offset' : 2,
                                                                     'bit length' : 1 })

        self.dataModel.addChild(externallyPowered)


        neverSinkEP = register_class.cForceSetDMTerminator( self,  { 'name' : 'Never Sink if Externally Powered',
                                                                'offset' : 30,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Flase (Ignore Externally Powered)'})

        self.dataModel.addChild(neverSinkEP)
        neverSinkEP.setFromInt(0)
        if hide_simplified :
            neverSinkEP.hide()


        powSwap = register_class.cVirtualListDMTerminator(self,
                                                      {'name' : 'Power Swap Strategy',
                                                        'offset' : 0,
                                                        'bit length' : 2 })

        powSwap.setReportList(['No Preference, Rejects All Swaps', 'No Preference, Supports All Swaps', 'Prefers Power Source', 'Prefers Power Sink'])
        powSwap.registerAsDerivedField(powSwapDerivedFxn, powSwapUpdateFxn,
         [ \
            ['Control Configuration', 'Process Swap To Sink'], \
            ['Control Configuration', 'Initiate Swap To Sink'], \
            ['Control Configuration', 'Process Swap To Source'], \
            ['Control Configuration', 'Initiate Swap To Source'], \
            ])

        powSwap.addUpdateRegisterByName("self")

        self.dataModel.addChild(powSwap)


        processSwTSk = register_class.cBooleanDMTerminator(self,
                                                                    {'name' : 'Process Swap To Sink',
                                                                     'offset' : 4,
                                                                     'bit length' : 1 })

        processSwTSk.hide()
        self.dataModel.addChild(processSwTSk)

        initSwTSk = register_class.cBooleanDMTerminator(self,
                                                                    {'name' : 'Initiate Swap To Sink',
                                                                     'offset' : 5,
                                                                     'bit length' : 1 })

        initSwTSk.hide()
        self.dataModel.addChild(initSwTSk)

        processSwTSr = register_class.cBooleanDMTerminator(self,
                                                                    {'name' : 'Process Swap To Source',
                                                                     'offset' : 6,
                                                                     'bit length' : 1 })

        processSwTSr.hide()
        self.dataModel.addChild(processSwTSr)

        initSwTSr = register_class.cBooleanDMTerminator(self,
                                                                    {'name' : 'Initiate Swap To Source',
                                                                     'offset' : 7,
                                                                     'bit length' : 1 })

        initSwTSr.hide()
        self.dataModel.addChild(initSwTSr)



        rdoInt = register_class.cForceSetDMTerminator( self,  { 'name' : 'RDO Intrusive Mode',
                                                                'offset' : 8,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(rdoInt)
        rdoInt.setFromInt(0)
        if hide_simplified :
            rdoInt.hide()

        pdoInt = register_class.cForceSetDMTerminator( self,  { 'name' : 'PDO Intrusive Mode',
                                                                'offset' : 9,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(pdoInt)
        pdoInt.setFromInt(0)
        if hide_simplified :
            pdoInt.hide()


        procVconnSw = register_class.cForceSetDMTerminator( self,  { 'name' : 'Process VCONN Swap',
                                                                'offset' : 10,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        self.dataModel.addChild(procVconnSw)
        procVconnSw.setFromInt(1)
        if hide_simplified :
            procVconnSw.hide()


        initVconnSw = register_class.cForceSetDMTerminator( self,  { 'name' : 'Initiate VCONN Swap',
                                                                'offset' : 11,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(initVconnSw)
        initVconnSw.setFromInt(0)
        if hide_simplified :
            initVconnSw.hide()


        dataSwap = register_class.cVirtualListDMTerminator(self,
                                                      {'name' : 'Data Swap Strategy',
                                                        'offset' : 0,
                                                        'bit length' : 2 })

        dataSwap.setReportList(['No Preference, Rejects All Swaps', 'No Preference, Supports All Swaps', 'Prefers Data DFP (host)', 'Prefers Data UFP (device)'])
        dataSwap.registerAsDerivedField(dataSwapDerivedFxn, dataSwapUpdateFxn,
         [ \
            ['Control Configuration', 'Process Swap To UFP'], \
            ['Control Configuration', 'Initiate Swap To UFP'], \
            ['Control Configuration', 'Process Swap To DFP'], \
            ['Control Configuration', 'Initiate Swap To DFP'], \
            ])

        dataSwap.addUpdateRegisterByName("self")

        self.dataModel.addChild(dataSwap)


        procSwUFP = register_class.cBooleanDMTerminator(self,
                                                                    {'name' : 'Process Swap To UFP',
                                                                     'offset' : 12,
                                                                     'bit length' : 1 })

        procSwUFP.hide()
        self.dataModel.addChild(procSwUFP)

        initSwUFP = register_class.cBooleanDMTerminator(self,
                                                                    {'name' : 'Initiate Swap To UFP',
                                                                     'offset' : 13,
                                                                     'bit length' : 1 })

        initSwUFP.hide()
        self.dataModel.addChild(initSwUFP)

        procSwDFP = register_class.cBooleanDMTerminator(self,
                                                                    {'name' : 'Process Swap To DFP',
                                                                     'offset' : 14,
                                                                     'bit length' : 1 })

        procSwDFP.hide()
        self.dataModel.addChild(procSwDFP)

        initSwDFP = register_class.cBooleanDMTerminator(self,
                                                                    {'name' : 'Initiate Swap To DFP',
                                                                     'offset' : 15,
                                                                     'bit length' : 1 })

        initSwDFP.hide()
        self.dataModel.addChild(initSwDFP)


        autoID = register_class.cForceSetDMTerminator( self,  { 'name' : 'Automatic ID Request',
                                                                'offset' : 24,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        self.dataModel.addChild(autoID)
        autoID.setFromInt(1)
        if hide_simplified :
            autoID.hide()


        intAM = register_class.cForceSetDMTerminator( self,  { 'name' : 'Intrusive Alternate Mode Support',
                                                                'offset' : 25,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(intAM)
        intAM.setFromInt(0)
        if hide_simplified :
            intAM.hide()


        forceUSBGen1 = register_class.cForceSetDMTerminator( self,  { 'name' : 'Force USB Generation 1',
                                                                'offset' : 31,
                                                                'bit length' : 1,
                                                                'force value' : 0,
                                                                'force display' : 'False'})

        self.dataModel.addChild(forceUSBGen1)
        forceUSBGen1.setFromInt(1)
        if hide_simplified :
            forceUSBGen1.hide()



        i2cTimeout = register_class.cForceSetDMTerminator( self,  { 'name' : 'I2C Timeout Period',
                                                                'offset' : 32,
                                                                'bit length' : 3,
                                                                'force value' : 7,
                                                                'force display' : '200 mSec'})

        self.dataModel.addChild(i2cTimeout)
        i2cTimeout.setFromInt(7)
        if hide_simplified :
            i2cTimeout.hide()




# display pdos based on numPdo
# not a method, but should be grouped with txSrcCap class
def RxSrcCap_TopLevelDMGenerator(self) :
    numSrcPdo = self.getChildByName('Number of Source PDOs').valueToInt()
    retDict = {'name' : self.name, 'grouping tier' : self.tier, 'data model list' : []  }
    retDict['data model list'].append(self.getChildByName('Number of Source PDOs').dataModelGenerator())
    for i in range(numSrcPdo) :
        retDict['data model list'].append(self.getChildByName('Source PDO %d' %(i+1)).dataModelGenerator())

    return retDict

class cRxSrcCap_0x30_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Received Source Capabilities',
                                                 'address' : 0x30,
                                                 'byte length' : 29,
                                                 'permission' : 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name' : 'Received Source Capabilities',
                                                        'offset' : 0,
                                                        'bit length' : 232 })


        numSrcPdo = register_class.cDecimalDMTerminator(self,
                                                                  {'name' : 'Number of Source PDOs',
                                                                   'offset' : 0,
                                                                   'bit length' : 3 })

        numSrcPdo.help = """Number of valid Source PDOs that will be transmitted to the sink at the other end of the USB Type-C cable using USB-PD protocol. The PD Controller can transmit between 0 and 7 Source PDOs"""
        numSrcPdo.updateRegisters.append(self)

        self.dataModel.addChild(numSrcPdo)

        sPdo1 = cDMSourcePdo1Array(self, 1, {'name' : 'Source PDO 1',
                                                    'offset' : 8,
                                                    'bit length' : 32,
                                                     'Is Receive' : True })
        self.dataModel.addChild(sPdo1)

        for i in range(2,8) :
            SrcPDOX = cDMAnySourcePdoArray(self, 1,
                                           {'name' : 'Source PDO %d' %i,
                                            'offset' : 8 + ( (i-1) * 32 ),
                                            'bit length' : 32 })

            self.dataModel.addChild(SrcPDOX)

        self.dataModel.setDataModelGenerator(RxSrcCap_TopLevelDMGenerator)



# display pdos based on numPdo
# not a method, but should be grouped with txSrcCap class
def RxSinkCap_TopLevelDMGenerator(self) :
    numSrcPdo = self.getChildByName('Number of Sink PDOs').valueToInt()
    retDict = {'name' : self.name, 'grouping tier' : self.tier, 'data model list' : []  }
    retDict['data model list'].append(self.getChildByName('Number of Sink PDOs').dataModelGenerator())
    for i in range(numSrcPdo) :
        retDict['data model list'].append(self.getChildByName('Sink PDO %d' %(i+1)).dataModelGenerator())

    return retDict

class cRxSinkCap_0x31_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Received Sink Capabilities',
                                                 'address' : 0x31,
                                                 'byte length' : 57,
                                                 'permission' : 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name' : 'Received Sink Capabilities',
                                                        'offset' : 0,
                                                        'bit length' : 456 })

        numSinkTerm = register_class.cDecimalDMTerminator(self,
                                                          {'name' : 'Number of Sink PDOs',
                                                           'offset' : 0,
                                                           'bit length' : 3 })
        numSinkTerm.help = """Number of valid sink PDOs that will be transmitted to the source at the other end of the USB Type-C cable using USB-PD protocol. The PD Controller can transmit between 0 and 7 Sink PDOs."""
        numSinkTerm.updateRegisters.append(self)

        # TODO: set max allowable value to 6 (instead of 0-7 from 3 bits)
        self.dataModel.addChild(numSinkTerm)

        sPdo1 = cDMSinkPdo1Array(self, 1, {'name' : 'Sink PDO 1',
                                        'offset' : 8,
                                        'bit length' : 32,
                                        'Is Receive' : True })

        self.dataModel.addChild(sPdo1)
        # need to figure out a more consistent approach, but can't initialize the value until it is placed in register
        sPdo1.getChildByName('Voltage').setFromInt(100)
        sPdo1.getChildByName('Supply Type').setFromInt(0)

        for i in range(2,7) :
            SnkPDOX = cDMAnySinkPdoArray(self, 1,
                                           {'name' : 'Sink PDO %d' %i,
                                            'offset' : 8 + ( (i-1) * 32 ),
                                            'bit length' : 32,
                                            'No RDO Extensions' : True })

            self.dataModel.addChild(SnkPDOX)

        self.dataModel.setDataModelGenerator(RxSinkCap_TopLevelDMGenerator)



# display pdos based on numPdo
# not a method, but should be grouped with txSrcCap class
def TxSrcCap_TopLevelDMGenerator(self) :
    numSrcPdo = self.getChildByName('Tx Source PDO Config').getChildByName('Number of Source PDOs').valueToInt()

    for i in range(7) :
        if i < numSrcPdo :
            self.getChildByName('Source PDO %d' %(i+1)).unhide()
        else :
            self.getChildByName('Source PDO %d' %(i+1)).hide()

    return self.childrenAsListDMGenerator()

def TxSinkCap_TopLevelDMGenerator(self) :
    numSinkPdo = self.getChildByName('Sink PDO Count').getChildByName('Number of Sink PDOs').valueToInt()

    for i in range(6) :
        if i < numSinkPdo :
            self.getChildByName('Sink PDO %d' %(i+1)).unhide()
        else :
            self.getChildByName('Sink PDO %d' %(i+1)).hide()

    return self.childrenAsListDMGenerator()


# four arguments:
# [0] PP_5V configuration
# [1] PP_HV configuration
# [2] PP_EXT configuration
# [3] Number of PDOs
def switchSourcePDO1CheckFxn(self, argumentList, newValue) :
    pp_5v = argumentList[0].valueToInt()
    pp_hv = argumentList[1].valueToInt()
    pp_ext = argumentList[2].valueToInt()
    numPDO = argumentList[3].valueToInt()

    if numPDO == 0 :
        return {'check failed' : False, \
                'message' : None, \
                'change list' : None, \
               }


    switchSetting_options_list = [ 'Internal 5 volt Power Path (PP_5V)', \
                                  'Internal High Voltage Power Path (PP_HV)', \
                                  'Internal 5 volt Power Path (PP_5V)', \
                                  'External High Voltage Power Path (PP_HVE)' \
                                 ]

    pp_5v_options_list = ['PP_5V0 switch not used (disabled)', \
                          'PP_5V0 switch configured for output', \
                         ]

    pp_HV_options_list = ['PP_HV switch not used (disabled)', \
                          'PP_HV switch configured for output', \
                          'PP_HV switch configured for input', \
                          'PP_HV switch configured for input, wait for SYS_RDY command', \
                         ]

    pp_EXT_options_list = ['PP_EXT not used (disabled)', \
                           'PP_EXT configured for output', \
                           'PP_EXT configured for input', \
                           'PP_EXT configured for input, wait for SYS_RDY command', \
                           'PP_EXT configured for input and output', \
                           'PP_EXT configured for input and output, wait for SYS_RDY command', \
                          ]

    if switchSetting_options_list[newValue] == 'Internal 5 volt Power Path (PP_5V)' :
        if pp_5v_options_list[pp_5v] == 'PP_5V0 switch configured for output' :
            return {'check failed' : False, \
                    'message' : None, \
                    'change list' : None, \
                   }
        else :
            return {'check failed' : True, \
                    'message' : 'Setting Transmit Source Capabilities PDO switch source to PP_5V requires that this switch be configured as an output in the System Configuration register.  Currently it is configured as: %s' %pp_5v_options_list[pp_5v], \
                    'change list' : [{'object' : argumentList[0], \
                                      'valid setting list' : [{'value': 1, 'description': pp_5v_options_list[1] },] \
                                     }], \
                   }
    elif switchSetting_options_list[newValue] == 'Internal High Voltage Power Path (PP_HV)' :
        if pp_HV_options_list[pp_hv] == 'PP_HV switch configured for output' :
            return {'check failed' : False, \
                    'message' : None, \
                    'change list' : None, \
                   }
        else :
            return {'check failed' : True, \
                    'message' : 'Setting Transmit Source Capabilities PDO switch source to PP_HV requires that this switch be configured as an output in the System Configuration register.  Currently it is configured as: %s' %pp_HV_options_list[pp_hv], \
                    'change list' : [{'object' : argumentList[1], \
                                      'valid setting list' : [{'value': 1, 'description': pp_HV_options_list[1] },] \
                                     }], \
                   }
    elif switchSetting_options_list[newValue] == 'External High Voltage Power Path (PP_HVE)' :
        if (pp_EXT_options_list[pp_ext] == 'PP_EXT configured for output') \
            or (pp_EXT_options_list[pp_ext] == 'PP_EXT configured for input and output') \
            or (pp_EXT_options_list[pp_ext] == 'PP_EXT configured for input and output, wait for SYS_RDY command' ):

            return {'check failed' : False, \
                    'message' : None, \
                    'change list' : None, \
                   }
        else :
            return {'check failed' : True, \
                    'message' : 'Setting Transmit Source Capabilities PDO switch source to PP_HVE requires that this switch be configured as an output in the System Configuration register.  Currently it is configured as: %s' %pp_EXT_options_list[pp_ext], \
                    'change list' : [{'object' : argumentList[2], \
                                      'valid setting list' : [{'value': 1, 'description': pp_EXT_options_list[1] }, \
                                        {'value': 4, 'description': pp_EXT_options_list[4] },
                                        {'value': 5, 'description': pp_EXT_options_list[5] },
                                      ] \
                                     }], \
                   }
    else :
        return {'check failed' : True, \
                'message' : 'Unknown input option to switchSourceCheckFxn', \
                'change list' : [{'object' : None, \
                                  'valid setting list' : None \
                                 }], \
               }




# three arguments:
# [0] PP_5V configuration
# [1] PP_HV configuration
# [2] PP_EXT configuration
# [3] Number of PDOs
def switchSourceCheckFxn(self, argumentList, newValue) :
    pp_5v = argumentList[0].valueToInt()
    pp_hv = argumentList[1].valueToInt()
    pp_ext = argumentList[2].valueToInt()
    numPDO = argumentList[3].valueToInt()

    if numPDO < self.pdoNumber :
        return {'check failed' : False, \
                'message' : None, \
                'change list' : None, \
               }

    switchSetting_options_list = ['Internal High Voltage Power Path (PP_HV)', \
                                  'External High Voltage Power Path (PP_HVE)' \
                                 ]

    pp_5v_options_list = ['PP_5V0 switch not used (disabled)', \
                          'PP_5V0 switch configured for output', \
                         ]

    pp_HV_options_list = ['PP_HV switch not used (disabled)', \
                          'PP_HV switch configured for output', \
                          'PP_HV switch configured for input', \
                          'PP_HV switch configured for input, wait for SYS_RDY command', \
                         ]

    pp_EXT_options_list = ['PP_EXT not used (disabled)', \
                           'PP_EXT configured for output', \
                           'PP_EXT configured for input', \
                           'PP_EXT configured for input, wait for SYS_RDY command', \
                           'PP_EXT configured for input and output', \
                           'PP_EXT configured for input and output, wait for SYS_RDY command', \
                          ]

    if switchSetting_options_list[newValue] == 'Internal High Voltage Power Path (PP_HV)' :
        if pp_HV_options_list[pp_hv] == 'PP_HV switch configured for output' :
            return {'check failed' : False, \
                    'message' : None, \
                    'change list' : None, \
                   }
        else :
            return {'check failed' : True, \
                    'message' : 'Setting Transmit Source Capabilities PDO switch source to PP_HV requires that this switch be configured as an output in the System Configuration register.  Currently it is configured as: %s' %pp_HV_options_list[pp_hv], \
                    'change list' : [{'object' : argumentList[1], \
                                      'valid setting list' : [{'value': 1, 'description': pp_HV_options_list[1] },] \
                                     }], \
                   }
    elif switchSetting_options_list[newValue] == 'External High Voltage Power Path (PP_HVE)' :
        if (pp_EXT_options_list[pp_ext] == 'PP_EXT configured for output') \
            or (pp_EXT_options_list[pp_ext] == 'PP_EXT configured for input and output') \
            or (pp_EXT_options_list[pp_ext] == 'PP_EXT configured for input and output, wait for SYS_RDY command' ):

            return {'check failed' : False, \
                    'message' : None, \
                    'change list' : None, \
                   }
        else :
            return {'check failed' : True, \
                    'message' : 'Setting Transmit Source Capabilities PDO switch source to PP_HVE requires that this switch be configured as an output in the System Configuration register.  Currently it is configured as: %s' %pp_EXT_options_list[pp_ext], \
                    'change list' : [{'object' : argumentList[2], \
                                      'valid setting list' : [{'value': 1, 'description': pp_EXT_options_list[1] }, \
                                        {'value': 4, 'description': pp_EXT_options_list[4] },
                                        {'value': 5, 'description': pp_EXT_options_list[5] },
                                      ] \
                                     }], \
                   }
    else :
        return {'check failed' : True, \
                'message' : 'Unknown input option to switchSourceCheckFxn', \
                'change list' : [{'object' : None, \
                                  'valid setting list' : None \
                                 }], \
               }



class cTxSrcCap_0x32_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Transmit Source Capabilities',
                                                 'address' : 0x32,
                                                 'byte length' : 31,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name' : 'Transmit Source Capabilities',
                                                        'offset' : 0,
                                                        'bit length' : 248 })

        SrcPdoConfig = register_class.cDataModelArray(self, 1,
                                                      {'name' : 'Tx Source PDO Config',
                                                        'offset' : 0,
                                                        'bit length' : 24 })

        self.dataModel.addChild(SrcPdoConfig)

        numSrcPdo = register_class.cDecimalDMTerminator(self,
                                                                  {'name' : 'Number of Source PDOs',
                                                                   'offset' : 0,
                                                                   'bit length' : 3 })

        numSrcPdo.addUpdateRegisterByName('self')

        SrcPdoConfig.addChild(numSrcPdo)

        switchDict = { 0 : 'Internal 5 volt Power Path (PP_5V)',
                       1 : 'Internal High Voltage Power Path (PP_HV)',
                       3 : 'External High Voltage Power Path (PP_HVE)'}

        switchReplaceDict = {2 : 0}

        SrcPDO1SwitchSource = register_class.cDictDMTerminator(self,
                                                      {'name' : 'Switch Source',
                                                        'offset' : 0,
                                                        'bit length' : 2 })

        SrcPDO1SwitchSource.setReportDict(switchDict)
        SrcPDO1SwitchSource.setReplaceDict(switchReplaceDict)

        SrcPDO1SwitchSource.setFixedOffset(16)


        sPdo1 = cDMSourcePdo1Array(self, 1, {'name' : 'Source PDO 1',
                                                    'offset' : 24,
                                                    'bit length' : 32 })

        sPdo1.prependChild(SrcPDO1SwitchSource)
        self.dataModel.addChild(sPdo1)
        # need to figure out a more consistent approach, but can't initialize the value until it is placed in register
        sPdo1.getChildByName('Voltage').setFromInt(100)
        sPdo1.getChildByName('Supply Type').setFromInt(0)

        SrcPDO1SwitchSource.registerAsCheckedField(switchSourcePDO1CheckFxn,
             [ \
                ['System Configuration', 'PP_5V0 Configuration'], \
                ['System Configuration', 'PP_HV Configuration'], \
                ['System Configuration', 'PP_EXT Configuration'], \
                ['self', 'Tx Source PDO Config', 'Number of Source PDOs'], \
             ])


        for i in range(2,8) :
            SrcPDOX = cDMAnySourcePdoArray(self, 1,
                                           {'name' : 'Source PDO %d' %i,
                                            'offset' : 24 + ( (i-1) * 32 ),
                                            'bit length' : 32 })

            SrcPDOXAdvertised = register_class.cListDMTerminator( self,
                                                                  {'name' : 'Advertised Mask',
                                                                   'offset' : 0,
                                                                   'bit length' : 1})

            SrcPDOXAdvertised.setReportList(['Advertise only if Externally Powered', 'Always Advertise'])
            SrcPDOXAdvertised.setFixedOffset(8 + i)

            SrcPDOXSwitchSource = register_class.cListDMTerminator( self,
                                                                    {'name' : 'Switch Source',
                                                                     'offset' : 0,
                                                                     'bit length' : 1})

            SrcPDOXSwitchSource.setReportList(['Internal High Voltage Power Path (PP_HV)', 'External High Voltage Power Path (PP_HVE)'])
            SrcPDOXSwitchSource.setFixedOffset(16 + i)

            SrcPDOXSwitchSource.pdoNumber = i

            SrcPDOXSwitchSource.registerAsCheckedField(switchSourceCheckFxn,
                 [ \
                    ['System Configuration', 'PP_5V0 Configuration'], \
                    ['System Configuration', 'PP_HV Configuration'], \
                    ['System Configuration', 'PP_EXT Configuration'], \
                    ['self', 'Tx Source PDO Config', 'Number of Source PDOs'], \
                 ])

            SrcPDOX.prependChild(SrcPDOXSwitchSource)
            SrcPDOX.prependChild(SrcPDOXAdvertised)

            self.dataModel.addChild(SrcPDOX)

        self.dataModel.setDataModelGenerator(TxSrcCap_TopLevelDMGenerator)


class cTxSinkCap_0x33_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Transmit Sink Capabilities',
                                                 'address' : 0x33,
                                                 'byte length' : 57,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name' : 'Transmit Sink Capabilities',
                                                        'offset' : 0,
                                                        'bit length' : 456 })

        SrcPdoConfig = register_class.cDataModelArray(self, 1,
                                                      {'name' : 'Sink PDO Count',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        self.dataModel.addChild(SrcPdoConfig)

        numSinkTerm = register_class.cDecimalDMTerminator(self,
                                                          {'name' : 'Number of Sink PDOs',
                                                           'offset' : 0,
                                                           'bit length' : 3 })
        numSinkTerm.addUpdateRegisterByName('self')

        # TODO: set max allowable value to 6 (instead of 0-7 from 3 bits)
        SrcPdoConfig.addChild(numSinkTerm)

        sPdo1 = cDMSinkPdo1Array(self, 1, {'name' : 'Sink PDO 1',
                                        'offset' : 8,
                                        'bit length' : 32 })

        self.dataModel.addChild(sPdo1)
        # need to figure out a more consistent approach, but can't initialize the value until it is placed in register
        sPdo1.getChildByName('Voltage').setFromInt(100)
        sPdo1.getChildByName('Supply Type').setFromInt(0)

        for i in range(2,7) :
            SnkPDOX = cDMAnySinkPdoArray(self, 1,
                                           {'name' : 'Sink PDO %d' %i,
                                            'offset' : 8 + ( (i-1) * 32 ),
                                            'bit length' : 32 })

            self.dataModel.addChild(SnkPDOX)

        self.dataModel.setDataModelGenerator(TxSinkCap_TopLevelDMGenerator)



class cActiveContractPDO_0x34_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Active Contract PDO',
                                                 'address' : 0x34,
                                                 'byte length' : 4,
                                                 'permission' : 'DRO'})

        activePDO = cDMAnySourcePdoArray(self, 1,
                                       {'name' : 'Active Contract PDO',
                                        'offset' : 0 ,
                                        'bit length' : 32 })


        self.dataModel = activePDO


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cActiveContractRDO_0x35_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Active Contract RDO',
                                                 'address' : 0x35,
                                                 'byte length' : 4,
                                                 'permission' : 'DRO'})
                                                 #E.B. Not sure if RO or DO?

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Active Contract RDO',
                                                        'offset' : 0,
                                                        'bit length' : 32 })

        #E.B. Not sure how to populate this register (0x35) Active Contract RDO.

        maxOpCurrent = cPDOCurrentField( self,  { 'name' : 'Max/Min Operating Current',
                                                                'offset' : 0,
                                                                'bit length' : 10})

        self.dataModel.addChild(maxOpCurrent)

        operatingCurrent = cPDOCurrentField( self,  { 'name' : 'Operating Current',
                                                                'offset' : 10,
                                                                'bit length' : 10})

        self.dataModel.addChild(operatingCurrent)

        noUsbSuspend = register_class.cBooleanDMTerminator(self,
                                                          {'name' : 'No USB Suspend',
                                                           'offset' : 24,
                                                           'bit length' : 1 })

        self.dataModel.addChild( noUsbSuspend )

        usbCommCap = register_class.cBooleanDMTerminator(self,
                                                          {'name' : 'USB Communication Capable',
                                                           'offset' : 25,
                                                           'bit length' : 1 })

        self.dataModel.addChild( usbCommCap )

        capMismatch = register_class.cBooleanDMTerminator(self,
                                                          {'name' : 'Capability Mismatch',
                                                           'offset' : 26,
                                                           'bit length' : 1 })

        self.dataModel.addChild( capMismatch )

        giveback = register_class.cBooleanDMTerminator(self,
                                                          {'name' : 'Giveback Flag',
                                                           'offset' : 27,
                                                           'bit length' : 1 })

        self.dataModel.addChild( giveback )

        giveback = register_class.cDecimalDMTerminator(self,
                                                          {'name' : 'Object Position',
                                                           'offset' : 28,
                                                           'bit length' : 3 })

        self.dataModel.addChild( giveback )


def ANEGSinkDMGenerator(self) :
    autoCalc = self.getChildByName('Capabilities Mismatch Determination').getChildByName('Automatically Calculate Min Power Required').valueToInt()
    minPow = self.getChildByName('Capabilities Mismatch Determination').getChildByName('Minimum Power Required')

    if autoCalc == 1 :
        minPow.hide()
    else :
        minPow.unhide()

    return self.childrenAsListDMGenerator()



class cAutoNegSink_0x37_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Autonegotiate Sink',
                                                 'address' : 0x37,
                                                 'byte length' : 12,
                                                 'permission' : 'RW'})

        self.FORCESETAUTONEG = True

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name' : 'Autonegotitate Sink',
                                                        'offset' : 0,
                                                        'bit length' : 96 })

        genSetting = register_class.cDataModelArray(self, 1,
                                                      {'name' : 'General Settings',
                                                        'offset' : 0,
                                                        'bit length' : 32 })

        self.dataModel.addChild(genSetting)

        if self.FORCESETAUTONEG == True :
            autoNegSink = register_class.cForceSetDMTerminator(self,
                                                              {'name' : 'Autonegotiate Sink Enable',
                                                               'offset' : 0,
                                                               'bit length' : 1,
                                                               'force value' : int(1),
                                                                'force display' : 'Enabled'})
        else :
            autoNegSink = register_class.cBooleanDMTerminator(self,
                                                              {'name' : 'Autonegotiate Sink Enable',
                                                               'offset' : 0,
                                                               'bit length' : 1 })

        if self.FORCESETAUTONEG == True :
            autoNegVarSink = register_class.cForceSetDMTerminator(self,
                                                              {'name' : 'Autonegotiate Variable Sink Enable',
                                                               'offset' : 1,
                                                               'bit length' : 1,
                                                               'force value' : int(1),
                                                                'force display' : 'Enabled'})

        else :
            autoNegVarSink = register_class.cBooleanDMTerminator(self,
                                                              {'name' : 'Autonegotiate Variable Sink Enable',
                                                               'offset' : 1,
                                                               'bit length' : 1 })


        if self.FORCESETAUTONEG == True :
            autoNegBatSink = register_class.cForceSetDMTerminator(self,
                                                              {'name' : 'Autonegotiate Battery Sink Enable',
                                                               'offset' : 2,
                                                               'bit length' : 1,
                                                               'force value' : int(1),
                                                                'force display' : 'Enabled'})

        else :
            autoNegBatSink = register_class.cBooleanDMTerminator(self,
                                                              {'name' : 'Autonegotiate Battery Sink Enable',
                                                               'offset' : 2,
                                                               'bit length' : 1 })

        genSetting.addChild(autoNegSink)
        genSetting.addChild(autoNegVarSink)
        genSetting.addChild(autoNegBatSink)
        if self.FORCESETAUTONEG == True :
            autoNegSink.setFromInt(1)
            autoNegVarSink.setFromInt(1)
            autoNegBatSink.setFromInt(1)

        if self.FORCESETAUTONEG == True :
            USBCommCap = register_class.cForceSetDMTerminator(self,
                                                              {'name' : 'USB Communication Capable',
                                                               'offset' : 3,
                                                               'bit length' : 1,
                                                               'force value' : int(1),
                                                                'force display' : 'Enabled'})
            genSetting.addChild(USBCommCap)
        else :
            USBCommCap = register_class.cBooleanDMTerminator(self,
                                                              {'name' : 'USB Communication Capable',
                                                               'offset' : 3,
                                                               'bit length' : 1 })

            genSetting.addChild(USBCommCap)

        if self.FORCESETAUTONEG == True :
            offerPri = register_class.cForceSetDMTerminator(self,
                                                              {'name' : 'Offer Priority',
                                                               'offset' : 4,
                                                               'bit length' : 2,
                                                               'force value' : int(2),
                                                                'force display' : 'Choose Highest Power'})
            genSetting.addChild(offerPri)
        else :
            offerPri = register_class.cListDMTerminator(self,
                                                              {'name' : 'Offer Priority',
                                                               'offset' : 4,
                                                               'bit length' : 2 })

            offerPri.setReportList(['Choose Highest Current', 'Choose Highest Voltage', 'Choose Highest Power'])

            genSetting.addChild(offerPri)

        if self.FORCESETAUTONEG == True :
            offerPri = register_class.cForceSetDMTerminator(self,
                                                              {'name' : 'No USB Suspend',
                                                               'offset' : 6,
                                                               'bit length' : 1,
                                                               'force value' : int(1),
                                                                'force display' : 'Enabled'})
            genSetting.addChild(offerPri)
        else :
            offerPri = register_class.cBooleanDMTerminator(self,
                                                              {'name' : 'No USB Suspend',
                                                               'offset' : 6,
                                                               'bit length' : 1 })

            genSetting.addChild(offerPri)

        if self.FORCESETAUTONEG == True :
            giveBack = register_class.cForceSetDMTerminator(self,
                                                              {'name' : 'Giveback Flag',
                                                               'offset' : 7,
                                                               'bit length' : 1,
                                                               'force value' : int(0),
                                                                'force display' : 'Disabled'})
            genSetting.addChild(giveBack)
        else :
            giveBack = register_class.cBooleanDMTerminator(self,
                                                              {'name' : 'Giveback Flag',
                                                               'offset' : 7,
                                                               'bit length' : 1 })

            genSetting.addChild(giveBack)

        anegPower = register_class.cDataModelArray(self, 1,
                                                      {'name' : 'Capabilities Mismatch Determination',
                                                        'offset' : 8,
                                                        'bit length' : 24 })

        self.dataModel.addChild(anegPower)

        if self.FORCESETAUTONEG == True :
            autoMinPowReq = register_class.cForceSetDMTerminator(self,
                                                              {'name' : 'Automatically Calculate Min Power Required',
                                                               'offset' : 0,
                                                               'bit length' : 1,
                                                               'force value' : int(1),
                                                                'force display' : 'Enabled'})
            anegPower.addChild(autoMinPowReq)

        else :
            autoMinPowReq = register_class.cBooleanDMTerminator(self,
                                                          {'name' : 'Automatically Calculate Min Power Required',
                                                            'offset' : 0,
                                                            'bit length' : 1 })

            autoMinPowReq.addUpdateRegisterByName("self")
            anegPower.addChild(autoMinPowReq)


        if self.FORCESETAUTONEG == True :
            minPowerReq = register_class.cForceSetDMTerminator(self,
                                                              {'name' : 'Minimum Power Required',
                                                               'offset' : 8,
                                                               'bit length' : 10,
                                                               'force value' : int(61),
                                                                'force display' : '15.25 W'})
            anegPower.addChild(minPowerReq)

        else :
            minPowerReq = cPDOPowerField(self,
                                                              {'name' : 'Minimum Power Required',
                                                               'offset' : 8,
                                                               'bit length' : 10 })

            minPowerReq.addUpdateRegisterByName("self")
            anegPower.addChild(minPowerReq)

        self.dataModel.setDataModelGenerator(ANEGSinkDMGenerator)




# four arguments:
# [0] display port svid enable
# [1] display port mode enable
# [2] thunderbolt svid enable
# [3] thunderbolt mode enable
def altmodeQueueSVID1(argumentList) :
    if (argumentList[0].valueToInt() == 1) and (argumentList[1].valueToInt() == 1)  :
        DPIsSet = 1
    else :
        DPIsSet = 0

    if (argumentList[2].valueToInt() == 1) and (argumentList[3].valueToInt() == 1)  :
        TBTIsSet = 1
    else :
        TBTIsSet = 0

    if TBTIsSet == 1 :
        return 0x8087
    elif DPIsSet == 1 :
        return 0xFF01
    else :
        return 0


# four arguments:
# [0] display port svid enable
# [1] display port mode enable
# [2] thunderbolt svid enable
# [3] thunderbolt mode enable
def altmodeQueueMode1(argumentList) :
    if (argumentList[0].valueToInt() == 1) and (argumentList[1].valueToInt() == 1)  :
        DPIsSet = 1
    else :
        DPIsSet = 0

    if (argumentList[2].valueToInt() == 1) and (argumentList[3].valueToInt() == 1)  :
        TBTIsSet = 1
    else :
        TBTIsSet = 0

    if TBTIsSet == 1 :
        return 1
    elif DPIsSet == 1 :
        return 1
    else :
        return 0

# four arguments:
# [0] display port svid enable
# [1] display port mode enable
# [2] thunderbolt svid enable
# [3] thunderbolt mode enable
def altmodeQueueSVID2(argumentList) :
    if (argumentList[0].valueToInt() == 1) and (argumentList[1].valueToInt() == 1)  :
        DPIsSet = 1
    else :
        DPIsSet = 0

    if (argumentList[2].valueToInt() == 1) and (argumentList[3].valueToInt() == 1)  :
        TBTIsSet = 1
    else :
        TBTIsSet = 0

    if TBTIsSet == 1 :
        if DPIsSet == 1 :
            return 0xFF01
        else :
            return 0x0
    else :
        return 0


# four arguments:
# [0] display port svid enable
# [1] display port mode enable
# [2] thunderbolt svid enable
# [3] thunderbolt mode enable
def altmodeQueueMode2(argumentList) :
    if (argumentList[0].valueToInt() == 1) and (argumentList[1].valueToInt() == 1)  :
        DPIsSet = 1
    else :
        DPIsSet = 0

    if (argumentList[2].valueToInt() == 1) and (argumentList[3].valueToInt() == 1)  :
        TBTIsSet = 1
    else :
        TBTIsSet = 0

    if TBTIsSet == 1 :
        if DPIsSet == 1 :
            return 1
        else :
            return 0
    else :
        return 0






class cAltModeEntryQueue_0x38_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Alternate Mode Entry Queue',
                                                 'address' : 0x38,
                                                 'byte length' : 12,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name' : 'Alternate Mode Entry Queue',
                                                        'offset' : 0,
                                                        'bit length' : 96 })

        AMrec1 = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Alternate Mode Entry Queue record #1',
                                                        'offset' : 0,
                                                        'bit length' : 32 })

        self.dataModel.addChild(AMrec1)

        AQSvid = register_class.cHexDMTerminator( self,  { 'name' : 'SVID (Standard or Vendor ID)',
                                                    'offset' : 0,
                                                    'bit length' : 16})

        AMrec1.addChild(AQSvid)

        # note, there is no update function, so this field must be locked, i.e. derived only
        AQSvid.registerAsDerivedField(altmodeQueueSVID1, None,
         [ \
            ['Display Port Capabilities', 'Enable Display Port SID'], \
            ['Display Port Capabilities', 'Enable Display Port Mode 1'], \
            ['Intel VID Config Register', 'Intel VID Config Set', 'Enable Intel VID'], \
            ['Intel VID Config Register', 'Intel VID Config Set', 'Enable Intel Thunderbolt Mode'], \
            ])
        AQSvid.lock()

        AQMode = register_class.cHexDMTerminator( self,  { 'name' : 'Mode Number',
                                                    'offset' : 16,
                                                    'bit length' : 16})

        AMrec1.addChild(AQMode)

        # note, there is no update function, so this field must be locked, i.e. derived only
        AQMode.registerAsDerivedField(altmodeQueueMode1, None,
         [ \
            ['Display Port Capabilities', 'Enable Display Port SID'], \
            ['Display Port Capabilities', 'Enable Display Port Mode 1'], \
            ['Intel VID Config Register', 'Intel VID Config Set', 'Enable Intel VID'], \
            ['Intel VID Config Register', 'Intel VID Config Set', 'Enable Intel Thunderbolt Mode'], \
            ])
        AQMode.lock()

        AMrec2 = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Alternate Mode Entry Queue record #2',
                                                        'offset' : 32,
                                                        'bit length' : 32 })

        self.dataModel.addChild(AMrec2)

        AQSvid = register_class.cHexDMTerminator( self,  { 'name' : 'SVID (Standard or Vendor ID)',
                                                    'offset' : 0,
                                                    'bit length' : 16})

        AMrec2.addChild(AQSvid)

        # note, there is no update function, so this field must be locked, i.e. derived only
        AQSvid.registerAsDerivedField(altmodeQueueSVID2, None,
         [ \
            ['Display Port Capabilities', 'Enable Display Port SID'], \
            ['Display Port Capabilities', 'Enable Display Port Mode 1'], \
            ['Intel VID Config Register', 'Intel VID Config Set', 'Enable Intel VID'], \
            ['Intel VID Config Register', 'Intel VID Config Set', 'Enable Intel Thunderbolt Mode'], \
            ])
        AQSvid.lock()

        AQMode = register_class.cHexDMTerminator( self,  { 'name' : 'Mode Number',
                                                    'offset' : 16,
                                                    'bit length' : 16})

        AMrec2.addChild(AQMode)

        # note, there is no update function, so this field must be locked, i.e. derived only
        AQMode.registerAsDerivedField(altmodeQueueMode2, None,
         [ \
            ['Display Port Capabilities', 'Enable Display Port SID'], \
            ['Display Port Capabilities', 'Enable Display Port Mode 1'], \
            ['Intel VID Config Register', 'Intel VID Config Set', 'Enable Intel VID'], \
            ['Intel VID Config Register', 'Intel VID Config Set', 'Enable Intel Thunderbolt Mode'], \
            ])
        AQMode.lock()

        AMrec3 = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Alternate Mode Entry Queue record #3',
                                                        'offset' : 64,
                                                        'bit length' : 32 })

        self.dataModel.addChild(AMrec3)

        AQSvid = register_class.cForceSetDMTerminator( self,  { 'name' : 'SVID (Standard or Vendor ID)',
                                                    'offset' : 0,
                                                    'bit length' : 16,
                                                    'force value' : int(0),
                                                    'force display' : '0x0'})

        AMrec3.addChild(AQSvid)
        AQSvid.setFromInt(0)

        AQMode = register_class.cForceSetDMTerminator( self,  { 'name' : 'Mode Number',
                                                    'offset' : 16,
                                                    'bit length' : 16,
                                                    'force value' : int(0),
                                                    'force display' : '0x0'})

        AMrec3.addChild(AQMode)
        AQMode.setFromInt(0)

class cPowerStatus_0x3F_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Power Status',
                                                 'address' : 0x3F,
                                                 'byte length' : 2,
                                                 'permission' : 'DRO'})
                                                 #E.B. Not sure if this should be RO or DO?

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Power Status',
                                                        'offset' : 0,
                                                        'bit length' : 16 })

        PowerConnection = register_class.cListDMTerminator(self,
                                                          {'name' : 'Offer Priority',
                                                           'offset' : 0,
                                                           'bit length' : 1 })

        PowerConnection.help = """1b when a connection is present. 0b when there is no connection to the PD Controller."""
        PowerConnection.setReportList(['No Connection', 'Connection Present'])
        self.dataModel.addChild(PowerConnection)

        SourceSink = register_class.cListDMTerminator(self,
                                                          {'name' : 'Source or Sink',
                                                           'offset' : 1,
                                                           'bit length' : 1 })

        SourceSink.help = """1b connection provides power (PD Controller as Sink). 0b connection requests power (PD Controller as Source)."""
        SourceSink.setReportList(['Source', 'Sink'])
        self.dataModel.addChild(SourceSink)

        TypeCCurrent = register_class.cListDMTerminator(self,
                                                          {'name' : 'Type-C Current',
                                                           'offset' : 2,
                                                           'bit length' : 2 })

        TypeCCurrent.help = """1b connection provides power (PD Controller as Sink). 0b connection requests power (PD Controller as Source)."""
        TypeCCurrent.setReportList(['USB Default Current', '1.5A Current', '3A Current', 'PD Contract Negotiated'])
        self.dataModel.addChild(TypeCCurrent)

        BC12Detection = register_class.cListDMTerminator(self,
                                                          {'name' : 'BC 1.2 Detection',
                                                           'offset' : 4,
                                                           'bit length' : 1 })

        BC12Detection.help = """Determines if a BC 1.2 connection has been established on the Type-C port."""
        BC12Detection.setReportList(['USB BC v1.2 connection not yet established', 'USB BC v1.2 connection valid'])
        self.dataModel.addChild(BC12Detection)

        BC12Status = register_class.cListDMTerminator(self,
                                                          {'name' : 'BC 1.2 Status',
                                                           'offset' : 5,
                                                           'bit length' : 2 })

        BC12Status.help = """Displays the status of the BC1.2 Connection."""
        BC12Status.setReportList(['SDP Detected', 'Reserved', 'CDP Detected', 'DCP Detected'])
        self.dataModel.addChild(BC12Status)


########################################################################################################################
########################################################################################################################
########################################################################################################################

class cPDStatus_0x40_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'PD Status',
                                                 'address' : 0x40,
                                                 'byte length' : 4,
                                                 'permission' : 'DRO'})
                                                 #E.B. Not sure if this should be RO or DO?

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'PD Status',
                                                        'offset' : 0,
                                                        'bit length' : 32 })

        PlugDetails = register_class.cListDMTerminator(self,
                                                          {'name' : 'Plug Details',
                                                           'offset' : 0,
                                                           'bit length' : 2 })

        PlugDetails.help = """Displays details of the Type-C Plug."""
        PlugDetails.setReportList(['USB Type-C full-featured plug', 'USB 2.0 Type-C plug'])
        PlugDetails.setMaxValue(1)
        self.dataModel.addChild(PlugDetails)

        CCPullUp = register_class.cListDMTerminator(self,
                                                          {'name' : 'CC Pull-up',
                                                           'offset' : 2,
                                                           'bit length' : 2 })

        CCPullUp.help = """CC Pull-up value detected by PD Controller when in CC Pull-down mode"""
        CCPullUp.setReportList(['Not in CC pull-down mode / no CC pull-up detected.', 'USB Default Current', '1.5A Current', '3A Current'])
        CCPullUp.setMaxValue(3)
        self.dataModel.addChild(CCPullUp)

        PortType = register_class.cListDMTerminator(self,
                                                          {'name' : 'Port Type',
                                                           'offset' : 4,
                                                           'bit length' : 2 })

        PortType.help = """The PD Sink/Source role PD Controller is acting under."""
        PortType.setReportList(['Sink/Source', 'Sink', 'Source', 'Source/Sink'])
        PortType.setMaxValue(3)
        self.dataModel.addChild(PortType)

        PresentRole = register_class.cListDMTerminator(self,
                                                          {'name' : 'Present Role',
                                                           'offset' : 6,
                                                           'bit length' : 1 })

        PresentRole.help = """The PD source/sink role PD Controller is acting under."""
        PresentRole.setReportList(['Sink', 'Source'])
        PresentRole.setMaxValue(1)
        self.dataModel.addChild(PresentRole)

        SoftResetType = register_class.cListDMTerminator(self,
                                                          {'name' : 'Soft Reset Details',
                                                           'offset' : 8,
                                                           'bit length' : 5 })

        SoftResetType.help = """Displays details as to why a Soft Reset event occurred."""
        SoftResetType.setReportList(['Reset value, no soft reset', \
                                 'Soft reset received from far-end device.', \
                                 'Reserved', \
                                 'Soft reset sent, a GoodCRC was expected but something else was received', \
                                 'Soft reset sent because the received source capabilities message was invalid', \
                                 'Soft reset sent after retries were exhausted.', \
                                 'Soft reset sent due to receiving an accept message unexpectedly.', \
                                 'Reserved', \
                                 'Soft reset sent due to receiving a GetSinkCap message unexpectedly.', \
                                 'Soft reset sent due to receiving a GetSourceCap message unexpectedly.', \
                                 'Soft reset sent due to receiving a GotoMin message unexpectedly', \
                                 'Soft reset sent due to receiving a PS_RDY message unexpectedly.', \
                                 'Soft reset sent due to receiving a Ping message unexpectedly.', \
                                 'Soft reset sent due to receiving a Reject message unexpectedly.', \
                                 'Soft reset sent due to receiving a Request message unexpectedly.', \
                                 'Soft reset sent due to receiving a Sink Capabilities message unexpectedly', \
                                 'Soft reset sent due to receiving a Source Capabilities message unexpectedly', \
                                 'Soft reset sent due to receiving a Swap message unexpectedly.', \
                                 'Soft reset sent due to receiving a Wait Capabilities message unexpectedly', \
                                 'Soft reset sent due to receiving an unknown control message', \
                                 'Soft reset sent due to receiving an unknown data message.', \
                                 'Soft reset sent to initialize SOP’ controller in plug', \
                                 'Soft reset sent to initialize SOP’’ controller in plug', \
                                 ])
        SoftResetType.setMaxValue(23)
        self.dataModel.addChild(SoftResetType)

        HardResetDetails = register_class.cListDMTerminator(self,
                                                          {'name' : 'Hard Reset Details',
                                                           'offset' : 16,
                                                           'bit length' : 6 })

        HardResetDetails.help = """Displays details as to why a Hard Reset event occurred."""
        HardResetDetails.setReportList(['Reset value, no hard reset.', \
                                 'Required by the policy engine (signaling sent by far end).', \
                                 'Requested by host.', \
                                 'Invalid DR_Swap request during Active Mode', \
                                 'Required by policy engine, DischargeFailed', \
                                 'Required by policy engine, NoResponseTimeOut', \
                                 'Required by policy engine, SendSoftReset', \
                                 'Required by policy engine, Sink_SelectCapability.', \
                                 'Required by policy engine, Sink_TransitionSink.', \
                                 'Required by policy engine, Sink_WaitForCapabilities', \
                                 'Required by policy engine, SoftReset.', \
                                 'Required by policy engine, SourceOnTimeout', \
                                 'Required by policy engine, Source_CapabilityResponse', \
                                 'Required by policy engine, Source_SendCapabilities', \
                                 'Required by policy engine, SourcingFault', \
                                 'Required by policy engine, UnableToSource.', \
                                 ])
        HardResetDetails.setMaxValue(23)
        self.dataModel.addChild(HardResetDetails)


########################################################################################################################
########################################################################################################################
########################################################################################################################



class cDPSIDStatus_0x58_register(register_class.cRegister) :
    def __init__ (self):
        register_class.cRegister.__init__(self, {'register name' : 'DP SID Status',
                                                 'address' : 0x58,
                                                 'byte length' : 17,
                                                 'permission' : 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name' : 'DP SID Status',
                                                        'offset' : 0,
                                                        'bit length' : 136 })

        DPSIDDetected = register_class.cHexDMTerminator(self,
                                                      {'name' : 'DP SID Detected',
                                                        'offset' : 0,
                                                        'bit length' : 136 })
        DPSIDDetected.help = """0 (DFP_U/ UFP_U) - DP SID not detected\n\n 1 (DFP_U) - UFP_U returned to DP SID in Discover SVIDs response or responded with ACK to DP SID SVDM Commands\n\n 1 (UFP_U) - DFP_U has issued DP SID SVDM (DIscover Modes, Enter Modes, etc)."""
        self.dataModel.addChild(DPSIDDetected)

        DPModeActive = register_class.cHexDMTerminator(self,
                                                        {'name' : 'DP Mode Active',
                                                         'offset' : 1,
                                                         'bit length' : 1 })
        DPModeActive.help = """0 (DFP_U/ UFP_U) - DP SID not active \n\n1 (DFP_U) - PD Controller has entered DisplayPort Mode with attached UFP_U \n\n1 (UFP-U) - Attached DFP_U has entered DisplayPort Mode"""
        self.dataModel.addChild(DPModeActive)

        errorCode = register_class.cHexDMTerminator(self,
                                                      {'name' : 'Error Code',
                                                        'offset' : 2,
                                                        'bit length' : 3 })
        errorCode.help = """Error Code."""
        self.dataModel.addChild(errorCode)

        DPStatusTX = register_class.cHexDMTerminator(self,
                                                        {'name' : 'DP Status TX',
                                                        'offset' : 8,
                                                        'bit length' : 32 })
        DPStatusTX.help = """Current Outgoing DP Status message contents"""
        self.dataModel.addChild(DPStatusTX)

        DPStatusRX = register_class.cHexDMTerminator(self,
                                                        {'name' : 'DP Status RX',
                                                        'offset' : 40,
                                                        'bit length' : 32 })
        DPStatusRX.help = """Most recently received DP Status message contents"""
        self.dataModel.addChild(DPStatusRX)

        DPConfigure = register_class.cHexDMTerminator(self,
                                                        {'name' : 'DP Configure',
                                                        'offset' : 72,
                                                        'bit length' : 32 })
        DPConfigure.help = """Contents of DP Configure message when sent (DFP_U) or received (UFP_U)."""
        self.dataModel.addChild(DPConfigure)


        DPModeData = register_class.cHexDMTerminator(self,
                                                        {'name' : 'DP Mode Data',
                                                        'offset' : 104,
                                                        'bit length' : 32 })
        DPModeData.help = """Contents of DP Discover Mode response when received (DFP_U) or sent (UFP_U)."""
        self.dataModel.addChild(DPModeData)

########################################################################################################################
########################################################################################################################
########################################################################################################################

class cIntelVIDStatus_0x59_register(register_class.cRegister) :
    def __init__ (self):
        register_class.cRegister.__init__(self, {'register name' : 'Intel VID Status',
                                                 'address' : 0x59,
                                                 'byte length' : 11,
                                                 'permission' : 'DRO'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Intel VID Status',
                                                        'offset' : 0,
                                                        'bit length' : 88 })
        IntelVIDDetected = register_class.cHexDMTerminator(self,
                                                        {'name' : 'Intel VID Detected',
                                                        'offset' : 0,
                                                        'bit length' : 1 })
        IntelVIDDetected.help = """(DFP) UFP returned Intel VID in Discover SVIDs response or responded with ACK to Intel VID SVDM Commands\n\n(UFP) DFP has issued Intel VID SVDM (Discover Modes, Enter Mode, etc)"""
        self.dataModel.addChild(IntelVIDDetected)

        thunderboltModeActive = register_class.cHexDMTerminator(self,
                                                        {'name' : 'Thunderbolt Mode Active',
                                                        'offset' : 1,
                                                        'bit length' : 1 })
        thunderboltModeActive.help = """(DFP) PD Controller has entered Thunderbolt Mode with attached UFP\n\n(UFP) Attached DFP has entered Thunderbolt Mode """
        self.dataModel.addChild(thunderboltModeActive)

        errorCode = register_class.cHexDMTerminator(self,
                                                        {'name' : 'Error Code',
                                                        'offset' : 2,
                                                        'bit length' : 3 })
        errorCode.help = """Error Code"""
        self.dataModel.addChild(errorCode)

        TBTAttentionData = register_class.cHexDMTerminator(self,
                                                                {'name' : 'TBT Attention Data',
                                                                'offset' : 8,
                                                                'bit length' : 32 })
        TBTAttentionData.help = """Contents of Attention VDO in Thunderbolt Mode when sent (UFP) or received (DFP)"""
        self.dataModel.addChild(TBTAttentionData)

        TBTEnterModeData = register_class.cHexDMTerminator(self,
                                                                {'name' : 'TBT Attention Data',
                                                                'offset' : 40,
                                                                'bit length' : 16 })
        TBTEnterModeData.help = """Upper 16 bits of second VDO to Thunderbolt Enter Mode command when sent (DFP) or received (UFP)"""
        self.dataModel.addChild(TBTEnterModeData)

        TBTDiscoverModeDataSOP = register_class.cHexDMTerminator(self,
                                                                {'name' : 'TBT Discover Mode Data SOP',
                                                                'offset' : 56,
                                                                'bit length' : 16 })
        TBTDiscoverModeDataSOP.help = """Upper 16 bits of SOP Discover Modes response for TBT Mode when received (DFP) or sent (UFP). Lower 16 bits of the response are always 0x0001. \n\nNOTE: In the UFP role, this register simply copies the contents of the Intel VID Configuration register bits 23:8 at the time the Discover Modes response is generated."""
        self.dataModel.addChild(TBTDiscoverModeDataSOP)

        TBTDiscoverModeDataSOPP= register_class.cHexDMTerminator(self,
                                                                {'name' : 'TBT Discover Mode Data SOPP',
                                                                'offset' : 72,
                                                                'bit length' : 16 })
        TBTDiscoverModeDataSOPP.help = """Upper 16 bits of SOP' Discover Modes Cable response for TBT Mode. Lower 16 bits of the response are always 0x0001 """
        self.dataModel.addChild(TBTDiscoverModeDataSOPP)



def GPIODMGenerator(self) :
    event = self.getChildByName('Mapped Event')

    if self.offset not in preConfigMapDict :
        event.setFromInt(-2)

    eventListNum = event.valueToInt()

    if eventListNum == -2 :
        self.hide()
    else :
        self.unhide()

    if eventListNum == -2 :
        inout = 'neither'
    elif eventListNum == -1 :
        inout = 'output'
    else :
        inout = self.register.GPIOEventDictList[eventListNum]['inout']

    if inout == 'output' :
        self.getChildByName('Output Enable').hide()
        self.getChildByName('Interrupt Enable').hide()
        self.getChildByName('Initial Value').unhide()
        self.getChildByName('Open Drain Output Enable').unhide()
        self.getChildByName('GPIO Output Level').unhide()
        self.getChildByName('Internal Pull Down Enable').unhide()
        self.getChildByName('Internal Pull Up Enable').unhide()
        self.getChildByName('Map Pin to GPIO or ADC').hide()
    elif inout == 'input' :
        self.getChildByName('Output Enable').hide()
        self.getChildByName('Interrupt Enable').hide()
        self.getChildByName('Initial Value').hide()
        self.getChildByName('Open Drain Output Enable').hide()
        self.getChildByName('GPIO Output Level').hide()
        self.getChildByName('Internal Pull Down Enable').unhide()
        self.getChildByName('Internal Pull Up Enable').unhide()
        self.getChildByName('Map Pin to GPIO or ADC').hide()
    else :
        self.getChildByName('Output Enable').hide()
        self.getChildByName('Interrupt Enable').hide()
        self.getChildByName('Initial Value').hide()
        self.getChildByName('Open Drain Output Enable').hide()
        self.getChildByName('GPIO Output Level').hide()
        self.getChildByName('Internal Pull Down Enable').hide()
        self.getChildByName('Internal Pull Up Enable').hide()
        self.getChildByName('Map Pin to GPIO or ADC').hide()

    return self.childrenAsListDMGenerator()



muxConfigMapList = [ 'Plug Event',
                     'AMSEL event',
                     'Port Connected CC2 (Cable Orientation Event)',
                     ]

bjConfigMapList = [ 'Barrel Jack Detect Event',
                     ]

apsConfigMapList = [ 'Source PDOX Negotiated Truth Table LSB',
                     'Source PDOX Negotiated Truth Table Bit 2',
                     ]


def findGPIOIndex(GPIOEventDictList, tag) :
    for (i, recordDict) in enumerate(GPIOEventDictList) :
        if recordDict['name'] == tag :
            return i

    return None



#  This covers the flag offsets
#  Have to append event record since it uses different offset structure 
class cGPIOFlagOffsets(register_class.cDataModelArray) :
    def __init__(self, register, tier, virtual, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        enable = register_class.cBooleanDMTerminator(self.register,
                                                      {'name' : 'Output Enable',
                                                        'offset' : 0,
                                                        'bit length' : 1 })
        enable.hide()
        self.addChild(enable)

        intEnable = register_class.cBooleanDMTerminator(self.register,
                                                      {'name' : 'Interrupt Enable',
                                                        'offset' : 32,
                                                        'bit length' : 1 })
        intEnable.hide()
        self.addChild(intEnable)

        initData = register_class.cDataModelTerminator(self.register,
                                                      {'name' : 'Initial Value',
                                                        'offset' : 64,
                                                        'bit length' : 1 })

        initData.hide()
        self.addChild(initData)

        openDrain = register_class.cBooleanDMTerminator(self.register,
                                                      {'name' : 'Open Drain Output Enable',
                                                        'offset' : 96,
                                                        'bit length' : 1 })
        openDrain.hide()
        self.addChild(openDrain)

        ldo3P3 = register_class.cListDMTerminator(self.register,
                                                      {'name' : 'GPIO Output Level',
                                                        'offset' : 128,
                                                        'bit length' : 1 })

        ldo3P3.hide()
        ldo3P3.setReportList(['VDDIO', 'LDO3V3'])


        self.addChild(ldo3P3)

        intPullDown = register_class.cBooleanDMTerminator(self.register,
                                                      {'name' : 'Internal Pull Down Enable',
                                                        'offset' : 160,
                                                        'bit length' : 1 })

        intPullDown.hide()
        self.addChild(intPullDown)

        intPullUp = register_class.cBooleanDMTerminator(self.register,
                                                      {'name' : 'Internal Pull Up Enable',
                                                        'offset' : 192,
                                                        'bit length' : 1 })

        intPullUp.hide()
        self.addChild(intPullUp)

        hiZ = register_class.cListDMTerminator(self.register,
                                                      {'name' : 'Map Pin to GPIO or ADC',
                                                        'offset' : 224,
                                                        'bit length' : 1 })

        hiZ.setReportList(['GPIO', 'ADC (Hi-Z)'])
        hiZ.hide()
        self.addChild(hiZ)



#  This covers the flag offsets
#  Have to append event record since it uses different offset structure 
class cGPIOEventRecord(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        gpioDict = {}

        for i in range(self.register.NumMappableGPIO) :
            if i not in self.register.listGpioExclude :
                gpioDict[i] = 'GPIO %d' %i


        gpioNum = register_class.cDictDMTerminator(self.register,
                                                      {'name' : 'GPIO Number',
                                                        'offset' : 0,
                                                        'bit length' : 5 })

        gpioNum.setMaxValue(self.register.NumMappableGPIO -1)
        gpioNum.setReportDict(gpioDict)
        gpioNum.addUpdateRegisterByName("GPIO Event Map")
        self.addChild(gpioNum)

        eventEnable = register_class.cBooleanDMTerminator(self.register,
                                                      {'name' : 'Event Enable',
                                                        'offset' : 7,
                                                        'bit length' : 1 })

        self.addChild(eventEnable)

GPIOEventDictList = [
    {'name' : 'Disabled', 'inout' : 'neither' },
    {'name' : 'Output Enabled Without Event', 'inout' : 'output' },
    {'name' : 'Plug Event', 'inout' : 'output' },
    {'name' : 'Port Connected CC2 (Cable Orientation Event)', 'inout' : 'output' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'Source (1) / Sink (0) / Unattached (High-Z) event', 'inout' : 'output' },
    {'name' : 'reserved', 'inout' : 'input' },
    {'name' : 'Fault Condition (Active Low) Event', 'inout' : 'output' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'Either DP or USB Event', 'inout' : 'output' },
    {'name' : 'DP Mode Selection Event', 'inout' : 'output' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'Supply P5V Event', 'inout' : 'output' },
    {'name' : 'Supply HV Event', 'inout' : 'output' },
    {'name' : 'Supply HVE Event', 'inout' : 'output' },
    {'name' : 'Supply PPCable Event', 'inout' : 'output' },
    {'name' : 'Attached (Active Low) Event', 'inout' : 'output' },
    {'name' : 'VBUS Detect Event', 'inout' : 'output' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'P5V Overcurrent Event', 'inout' : 'output' },
    {'name' : 'Sink (1) / Source (0) Event', 'inout' : 'output' },
    {'name' : 'USB3 Event', 'inout' : 'output' },
    {'name' : 'USB2 Event', 'inout' : 'output' },
    {'name' : '2-lane DP Event', 'inout' : 'output' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'AMSEL event', 'inout' : 'output' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'PP_EXT Switch Closed Event', 'inout' : 'output' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'Sink < 12V Event', 'inout' : 'output' },
    {'name' : 'Sink = 12V Event', 'inout' : 'output' },
    {'name' : 'Sink > 12V Event', 'inout' : 'output' },
    {'name' : 'HS_SEL0 (DP Pin Assign ACE = 1, BDF=0)', 'inout' : 'output' },
    {'name' : 'UFP (0) / DFP (1) Event', 'inout' : 'output' },
    {'name' : 'DP or USB3 (Active Low) Event', 'inout' : 'output' },
    {'name' : 'AC Detect Event', 'inout' : 'output' },
    {'name' : 'Consumer No AC Event', 'inout' : 'output' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'Port Connected, CC1 Data Channel', 'inout' : 'output' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'reserved', 'inout' : 'neither' },
    {'name' : 'Barrel Jack Detect Event', 'inout' : 'input' },
    {'name' : 'PDIO (TI Alternate Mode) Input 0', 'inout' : 'input' },
    {'name' : 'PDIO (TI Alternate Mode) Input 1', 'inout' : 'input' },
    {'name' : 'PDIO (TI Alternate Mode) Input 2', 'inout' : 'input' },
    {'name' : 'PDIO (TI Alternate Mode) Input 3', 'inout' : 'input' },
    {'name' : 'PDIO (TI Alternate Mode) Output 0', 'inout' : 'output' },
    {'name' : 'PDIO (TI Alternate Mode) Output 1', 'inout' : 'output' },
    {'name' : 'PDIO (TI Alternate Mode) Output 2', 'inout' : 'output' },
    {'name' : 'PDIO (TI Alternate Mode) Output 3', 'inout' : 'output' },
    {'name' : 'Source PDO0 Negotiated ', 'inout' : 'output' },
    {'name' : 'Source PDO1 Negotiated ', 'inout' : 'output' },
    {'name' : 'Source PDO2 Negotiated ', 'inout' : 'output' },
    {'name' : 'Source PDO3 Negotiated ', 'inout' : 'output' },
    {'name' : 'Source PDOX Negotiated Truth Table LSB', 'inout' : 'output' },
    {'name' : 'Source PDOX Negotiated Truth Table Bit 2', 'inout' : 'output' },
    {'name' : 'Source PDOX Negotiated Truth Table MSB', 'inout' : 'output' },
    {'name' : 'VBUS UVP Quick Detect', 'inout' : 'output' },
    {'name' : 'reserved', 'inout' : 'input' },
    {'name' : 'reserved', 'inout' : 'output' },
    {'name' : 'Load App Config Set 1', 'inout' : 'input' },
    {'name' : 'Load App Config Set 2', 'inout' : 'input' },
    {'name' : 'Load App Config Set 3', 'inout' : 'input' },
    {'name' : 'USB EP Enable', 'inout' : 'input' },
    {'name' : 'HV or EXT Sink Event (Active high after Softstart)', 'inout' : 'output'},
]


muxConfigMapList = [ 'Plug Event',
                     'AMSEL event',
                     'Port Connected CC2 (Cable Orientation Event)',
                     ]

bjConfigMapList = [ 'Barrel Jack Detect Event',
                     ]

apsConfigMapList = [ 'Source PDOX Negotiated Truth Table LSB',
                     'Source PDOX Negotiated Truth Table Bit 2',
                     ]

# three arguments:
# [0] plug event enable
# [1] AMSEL event enable
# [2] Port Connected CC2 event enable
def externMuxDerivedFxn(argumentList) :
    if (argumentList[0].valueToInt() == 1) and (argumentList[1].valueToInt() == 1) and (argumentList[2].valueToInt() == 1)  :
        isSet = 1
    else :
        isSet = 0

    # force consistency
    argumentList[0].setFromInt(isSet)
    argumentList[1].setFromInt(isSet)
    argumentList[2].setFromInt(isSet)

    return isSet

# three arguments:
# [0] plug event enable
# [1] AMSEL event enable
# [2] Port Connected CC2 event enable
def externMuxUpdateFxn(value, argumentList) :
    argumentList[0].setFromInt(value)
    argumentList[1].setFromInt(value)
    argumentList[2].setFromInt(value)


# one argument:
# [0] barrel jack event enable
def barreljackDerivedFxn(argumentList) :
    return argumentList[0].valueToInt()

# one argument:
# [0] barrel jack event enable
def barreljackUpdateFxn(value, argumentList) :
    argumentList[0].setFromInt(value)

# two arguments:
# [0] pdo truth table LSB enable
# [1] pdo truth table bit2 enable
def adjPSDerivedFxn(argumentList) :
    if (argumentList[0].valueToInt() == 1) and (argumentList[1].valueToInt() == 1) :
        isSet = 1
    else :
        isSet = 0

    # force consistency
    argumentList[0].setFromInt(isSet)
    argumentList[1].setFromInt(isSet)

    return isSet

# two arguments:
# [0] pdo truth table LSB enable
# [1] pdo truth table bit2 enable
def adjPSUpdateFxn(value, argumentList) :
    argumentList[0].setFromInt(value)
    argumentList[1].setFromInt(value)


def gpioEvtX_DMGenerator(self) :
    if self.getChildByName('Event Enable').valueToInt() == 1 :
        self.unhide()
    else :
        self.hide()

    return self.childrenAsListDMGenerator()


def combineEvents_DMGenerator(self) :
    otherReg = self.register.device.registerFromName('GPIO Event Map (0x5D)').dataModel
    myDM = self.childrenAsListDMGenerator()
    otherDM = otherReg.childrenAsListDMGenerator()

    totalDM = self.childrenAsListDMGenerator()
    totalDM['data model list'] = myDM['data model list'][1:]
    totalDM['data model list'].extend(otherDM['data model list'])

    muxSet = self.getChildByName('External GPIO Functions').getChildByName('External USB3/DP SS Mux').valueToInt()
    bjSet = self.getChildByName('External GPIO Functions').getChildByName('Barrel Jack Detect').valueToInt()
    apsSet = self.getChildByName('External GPIO Functions').getChildByName('Adjustable Power Supply').valueToInt()


    retDict = {'name' : self.name, 'grouping tier' : 2, 'show' : 1, 'data model list' : []  }

    # first data model is the high level GPIO selector box
    retDict['data model list'].append(myDM['data model list'][0])

    muxDict = {'name' : 'USB/DP External Mux GPIO',
                  'grouping tier' : 2, 'show' : muxSet,
                  'data model list' : []  }

    bjDict = {'name' : 'Barrel Jack Detect GPIO',
                  'grouping tier' : 2, 'show' : bjSet,
                  'data model list' : []  }

    apsDict = {'name' : 'Adjustable Power Supply GPIO',
                  'grouping tier' : 2, 'show' : apsSet,
                  'data model list' : []  }

    retDict['data model list'].append(muxDict)
    retDict['data model list'].append(bjDict)
    retDict['data model list'].append(apsDict)

    # reclaim unused GPIO
    for i in range(self.register.NumMappableGPIO) :
        gpioFlags = self.getChildByName('Settings for GPIO #%d' %(i))
        gpioFlags.getChildByName('Output Enable').setFromInt(0) 
        gpioFlags.getChildByName('Interrupt Enable').setFromInt(0)

    for evtRec in totalDM['data model list'] :
        for match in muxConfigMapList :
            if match in evtRec['name'] :
                muxDict['data model list'].append(evtRec)
                evtRec['data model list'][1].hide()
                if (evtRec['data model list'][1].valueToInt() == 1) :
                    gpioToChange = evtRec['data model list'][0].valueToInt()
                    gpioFlags = self.getChildByName('Settings for GPIO #%d' %(gpioToChange))
                    if findGPIOIndex(self.register.GPIOEventDictList, match) is not None :
                        if 'inout' in self.register.GPIOEventDictList[findGPIOIndex(self.register.GPIOEventDictList, match)] :
                            if (self.register.GPIOEventDictList[findGPIOIndex(self.register.GPIOEventDictList, match)]['inout'] == 'output') :
                                gpioFlags.getChildByName('Output Enable').setFromInt(1) 
                                gpioFlags.getChildByName('Interrupt Enable').setFromInt(0)
                            elif (self.register.GPIOEventDictList[findGPIOIndex(self.register.GPIOEventDictList, match)]['inout'] == 'input') :
                                gpioFlags.getChildByName('Output Enable').setFromInt(0) 
                                gpioFlags.getChildByName('Interrupt Enable').setFromInt(1)
                            else :
                                gpioFlags.getChildByName('Output Enable').setFromInt(0) 
                                gpioFlags.getChildByName('Interrupt Enable').setFromInt(0)

                        
        for match in bjConfigMapList :
            if match in evtRec['name'] :
                bjDict['data model list'].append(evtRec)
                evtRec['data model list'][1].hide()
                if (evtRec['data model list'][1].valueToInt() == 1) :
                    gpioToChange = evtRec['data model list'][0].valueToInt()
                    gpioFlags = self.getChildByName('Settings for GPIO #%d' %(gpioToChange))
                    if findGPIOIndex(self.register.GPIOEventDictList, match) is not None :
                        if 'inout' in self.register.GPIOEventDictList[findGPIOIndex(self.register.GPIOEventDictList, match)] :
                            if (self.register.GPIOEventDictList[findGPIOIndex(self.register.GPIOEventDictList, match)]['inout'] == 'output') :
                                gpioFlags.getChildByName('Output Enable').setFromInt(1) 
                                gpioFlags.getChildByName('Interrupt Enable').setFromInt(0)
                            elif (self.register.GPIOEventDictList[findGPIOIndex(self.register.GPIOEventDictList, match)]['inout'] == 'input') :
                                gpioFlags.getChildByName('Output Enable').setFromInt(0) 
                                gpioFlags.getChildByName('Interrupt Enable').setFromInt(1)
                            else :
                                gpioFlags.getChildByName('Output Enable').setFromInt(0) 
                                gpioFlags.getChildByName('Interrupt Enable').setFromInt(0)



        for match in apsConfigMapList :
            if match in evtRec['name'] :
                apsDict['data model list'].append(evtRec)
                evtRec['data model list'][1].hide()
                if (evtRec['data model list'][1].valueToInt() == 1) :
                    gpioToChange = evtRec['data model list'][0].valueToInt()
                    gpioFlags = self.getChildByName('Settings for GPIO #%d' %(gpioToChange))
                    if findGPIOIndex(self.register.GPIOEventDictList, match) is not None :
                        if 'inout' in self.register.GPIOEventDictList[findGPIOIndex(self.register.GPIOEventDictList, match)] :
                            if (self.register.GPIOEventDictList[findGPIOIndex(self.register.GPIOEventDictList, match)]['inout'] == 'output') :
                                gpioFlags.getChildByName('Output Enable').setFromInt(1) 
                                gpioFlags.getChildByName('Interrupt Enable').setFromInt(0)
                            elif (self.register.GPIOEventDictList[findGPIOIndex(self.register.GPIOEventDictList, match)]['inout'] == 'input') :
                                gpioFlags.getChildByName('Output Enable').setFromInt(0) 
                                gpioFlags.getChildByName('Interrupt Enable').setFromInt(1)
                            else :
                                gpioFlags.getChildByName('Output Enable').setFromInt(0) 
                                gpioFlags.getChildByName('Interrupt Enable').setFromInt(0)

    # HI-Z any unused GPIO    
    for i in range(self.register.NumMappableGPIO) :
        gpioFlags = self.getChildByName('Settings for GPIO #%d' %(i))
        if (gpioFlags.getChildByName('Output Enable').valueToInt() == 1) or (gpioFlags.getChildByName('Interrupt Enable').valueToInt() == 1) :
            gpioFlags.getChildByName('Map Pin to GPIO or ADC').setFromInt(0)
        else:
            gpioFlags.getChildByName('Map Pin to GPIO or ADC').setFromInt(1)
        

    # build output for show hidden.  dont repeat events
        
    for i in range(self.register.NumMappableGPIO) :
        gpioFlags = self.getChildByName('Settings for GPIO #%d' %(i))
        if gpioFlags is not None :
            retDict['data model list'].append(gpioFlags.childrenAsListDMGenerator())

    for i in range(32) :
        gpioEvtX = self.getChildByName('GPIO Event #%d -- %s' %(i, self.register.GPIOEventDictList[i]['name']))
        if (gpioEvtX is not None) and (gpioEvtX.getChildByName('Event Enable').valueToInt() == 0 ) :
            retDict['data model list'].append(gpioEvtX.childrenAsListDMGenerator())

    for i in range(32, self.register.NumGPIOEvents) :
        gpioEvtX = otherReg.getChildByName('GPIO Event #%d -- %s' %(i, self.register.GPIOEventDictList[i]['name']))
        if (gpioEvtX is not None) and (gpioEvtX.getChildByName('Event Enable').valueToInt() == 0 ) :
            retDict['data model list'].append(gpioEvtX.childrenAsListDMGenerator())

    return retDict

class cGPIOEventMap_0x5C_register(register_class.cRegister) :
    def __init__(self):
        global muxConfigMapList
        global bjConfigMapList
        global apsConfigMapList

        self.NumMappableGPIO = 18
        self.listGpioExclude = [4, 9, 10, 11]

        # remove the first "no enabled event" event
        self.GPIOEventDictList = GPIOEventDictList[2:]

        # determine number of events before removing reserved
        self.NumGPIOEvents = len(self.GPIOEventDictList) -2

        register_class.cRegister.__init__(self, {'register name' : 'GPIO Event Map',
                                                 'address' : 0x5C,
                                                 'byte length' : 64,
                                                 'permission' : 'RW'})


        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name' : 'GPIO Event Map',
                                                        'offset' : 0,
                                                        'bit length' : 8 * (32 + self.NumGPIOEvents) })

        gpioHighLevel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'External GPIO Functions',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        self.dataModel.addChild(gpioHighLevel)

        externMux = register_class.cVirtualBooleanDMTerminator(self,
                                                      {'name' : 'External USB3/DP SS Mux',
                                                        'offset' : 0,
                                                        'bit length' : 1 })


        muxFields = []
        for evt in muxConfigMapList :
            i = findGPIOIndex(self.GPIOEventDictList, evt)
            if i < 32 :
                muxFields.append(['self', 'GPIO Event #%d -- %s' %(i, self.GPIOEventDictList[i]['name']), 'Event Enable'])
            else :
                muxFields.append(['GPIO Event Map (0x5D)', 'GPIO Event #%d -- %s' %(i, self.GPIOEventDictList[i]['name']), 'Event Enable'])

        externMux.registerAsDerivedField(externMuxDerivedFxn, externMuxUpdateFxn, muxFields)
        externMux.addUpdateRegisterByName("self")

        gpioHighLevel.addChild(externMux)

        barreljack = register_class.cVirtualBooleanDMTerminator(self,
                                                      {'name' : 'Barrel Jack Detect',
                                                        'offset' : 0,
                                                        'bit length' : 1 })

        bjFields = []
        for evt in bjConfigMapList :
            i = findGPIOIndex(self.GPIOEventDictList, evt)
            if i < 32 :
                bjFields.append(['self', 'GPIO Event #%d -- %s' %(i, self.GPIOEventDictList[i]['name']), 'Event Enable'])
            else :
                bjFields.append(['GPIO Event Map (0x5D)', 'GPIO Event #%d -- %s' %(i, self.GPIOEventDictList[i]['name']), 'Event Enable'])

        barreljack.registerAsDerivedField(barreljackDerivedFxn, barreljackUpdateFxn, bjFields)

        barreljack.addUpdateRegisterByName("self")
        gpioHighLevel.addChild(barreljack)


        adjPS = register_class.cVirtualBooleanDMTerminator(self,
                                                      {'name' : 'Adjustable Power Supply',
                                                        'offset' : 0,
                                                        'bit length' : 1 })

        apsFields = []
        for evt in apsConfigMapList :
            i = findGPIOIndex(self.GPIOEventDictList, evt)
            if i < 32 :
                apsFields.append(['self', 'GPIO Event #%d -- %s' %(i, self.GPIOEventDictList[i]['name']), 'Event Enable'])
            else :
                apsFields.append(['GPIO Event Map (0x5D)', 'GPIO Event #%d -- %s' %(i, self.GPIOEventDictList[i]['name']), 'Event Enable'])

        adjPS.registerAsDerivedField(adjPSDerivedFxn, adjPSUpdateFxn, apsFields)
        adjPS.addUpdateRegisterByName("self")

        gpioHighLevel.addChild(adjPS)

        self.eventReportDict = {}
        self.eventReplaceDict = {}

        for (i, eventDict) in enumerate(GPIOEventDictList) :
            if GPIOEventDictList[i]['name'] != 'reserved' :
                self.eventReportDict[i-2] = GPIOEventDictList[i]['name']


        for i in range(self.NumMappableGPIO) :
            gpioFlags = cGPIOFlagOffsets(self, 1, True,
                                                        {'name' : 'Settings for GPIO #%d' %(i),
                                                        'offset' : i,
                                                        'bit length' : 480 })
            self.dataModel.addChild(gpioFlags)
            gpioFlags.hide()


        for i in range(32) :

            gpioEvtX = cGPIOEventRecord(self, 1,
                                                              {'name' : 'GPIO Event #%d -- %s' %(i, self.GPIOEventDictList[i]['name']),
                                                               'offset' : 256 + (8*i),
                                                               'bit length' : 8 })

            self.dataModel.addChild(gpioEvtX)
            gpioEvtX.setDataModelGenerator(gpioEvtX_DMGenerator)
            gpioEvtX.hide()

        self.dataModel.setDataModelGenerator(combineEvents_DMGenerator)


class cGPIOEventMap_0x5D_register(register_class.cRegister) :
    def __init__(self):
        self.NumMappableGPIO = 18
        self.listGpioExclude = [4, 9, 10, 11]

        # remove the first "no enabled event" event
        self.GPIOEventDictList = GPIOEventDictList[2:]

        # determine number of events before removing reserved
        self.NumGPIOEvents = len(self.GPIOEventDictList) - 2

        register_class.cRegister.__init__(self, {'register name' : 'GPIO Event Map (0x5D)',
                                                 'address' : 0x5D,
                                                 'byte length' : 64,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name' : 'GPIO Event Map (0x5D)',
                                                        'offset' : 0,
                                                        'bit length' : 8 * (32 + self.NumGPIOEvents) })

        for i in range(self.NumGPIOEvents - 32) :

            gpioEvtX = cGPIOEventRecord(self, 1,
                                                              {'name' : 'GPIO Event #%d -- %s' %(i+32, self.GPIOEventDictList[i+32]['name']),
                                                               'offset' : 8*i,
                                                               'bit length' : 8 })
            gpioEvtX.setDataModelGenerator(gpioEvtX_DMGenerator)
            self.dataModel.addChild(gpioEvtX)

        self.showRawOnly()

def intFrom4CC(value) :
    retVal = 0x0
    # little endian. First char takes position 0 of the array
    for (i,char) in enumerate(value) :
        retVal |= (ord(char) << (8*i))

    return retVal

cmdReportDict =  { intFrom4CC('!CMD') : '!CMD',
                   intFrom4CC('Gaid') : 'Gaid',
                   intFrom4CC('GAID') : 'GAID',
                   intFrom4CC('ANeg') : 'ANeg',
                   intFrom4CC('CRST') : 'CRST',
                   intFrom4CC('DBfg') : 'DBfg',
#                   intFrom4CC('FPWR') : 'FPWR',
#                   intFrom4CC('GPIO') : 'GPIO',
                   intFrom4CC('GPoe') : 'GPoe',
                   intFrom4CC('GPie') : 'GPie',
                   intFrom4CC('GPsh') : 'GPsh',
                   intFrom4CC('GPsl') : 'GPsl',
                   intFrom4CC('HRST') : 'HRST',
#                   intFrom4CC('LOCK') : 'LOCK',
#                   intFrom4CC('MEMr') : 'MEMr',
#                   intFrom4CC('MEMw') : 'MEMw',
#                   intFrom4CC('PDOf') : 'PDOf',
#                   intFrom4CC('PDTx') : 'PDTx',
                   intFrom4CC('SRDY') : 'SRDY',
                   intFrom4CC('SRYR') : 'SRYR',
#                   intFrom4CC('VDMs') : 'VDMs'
                }

cmdTaskReportDict = { intFrom4CC('!CMD') : '!CMD',
                  intFrom4CC('Gaid') : 'Gaid',
                  intFrom4CC('GAID') : 'GAID',
#                   intFrom4CC('ABRT') : 'ABRT',
                  intFrom4CC('AMDs') : 'AMDs',
                  intFrom4CC('AMDs') : 'AMEn',
                  intFrom4CC('AMEn') : 'AMEx',
                  intFrom4CC('AMEx') : 'ANeg',
#                  intFrom4CC('ASkE') : 'ASkE',
                  intFrom4CC('CRST') : 'CRST',
                  intFrom4CC('DBfg') : 'DBfg',
#                   intFrom4CC('FPWR') : 'FPWR',
                  intFrom4CC('GO2M') : 'GO2M',
#                   intFrom4CC('GPIO') : 'GPIO',
#                   intFrom4CC('GPMp') : 'GPMp',
                   intFrom4CC('GPoe') : 'GPoe',
                   intFrom4CC('GPie') : 'GPie',
                   intFrom4CC('GPsh') : 'GPsh',
                   intFrom4CC('GPsl') : 'GPsl',
                  intFrom4CC('GSkC') : 'GSkC',
                  intFrom4CC('GSrC') : 'GSrC',
                  intFrom4CC('HRST') : 'HRST',
#                  intFrom4CC('ISkE') : 'ISkE',
#                   intFrom4CC('LOCK') : 'LOCK',
#                   intFrom4CC('MDEr') : 'MDEr',
#                   intFrom4CC('MDEw') : 'MDEw',
#                   intFrom4CC('MEMr') : 'MEMr',
#                   intFrom4CC('MEMw') : 'MEMw',
#                   intFrom4CC('PDOf') : 'PDOf',
#                   intFrom4CC('PDTx') : 'PDTx',
                  intFrom4CC('SRDY') : 'SRDY',
                  intFrom4CC('SRYR') : 'SRYR',
                  intFrom4CC('SSrC') : 'SSrC',
                  intFrom4CC('SWDF') : 'SWDF',
                  intFrom4CC('SWSk') : 'SWSk',
                  intFrom4CC('SWSr') : 'SWSr',
                  intFrom4CC('SWUF') : 'SWUF',
                  intFrom4CC('SWVC') : 'SWVC',
#                   intFrom4CC('VDMs') : 'VDMs'
                      }


class cUserAMGpioCfgSet(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        AppCfgMaskLow = register_class.cHexDMTerminator(self.register,
                                        {'name' : 'App Config Mask, GPIO Low Transition or USer AM Exit',
                                         'offset' : 0,
                                         'bit length' : 8 })

        self.addChild(AppCfgMaskLow)

        AppCfgMaskHigh = register_class.cHexDMTerminator(self.register,
                                        {'name' : 'App Config Mask, GPIO High Transition or USer AM Enter',
                                         'offset' : 8,
                                         'bit length' : 8 })

        self.addChild(AppCfgMaskHigh)

        cmdOnlyChannel = register_class.cListDMTerminator(self.register,
                                        {'name' : 'Command Channel to use for Command (not Task) Slot',
                                         'offset' : 16,
                                         'bit length' : 2 })

        cmdOnlyChannel.setMaxValue(2)
        cmdOnlyChannel.setReportList(['CMD1 (0x08)', 'CMD2 (0x09)', 'CMD3 (0x1E)'])

        self.addChild(cmdOnlyChannel)


        reserved = register_class.cForceSetDMTerminator( self.register,  { 'name' : 'Reserved',
                                                                'offset' : 18,
                                                                'bit length' : 6,
                                                                'force value' : int(0),
                                                                'force display' : 'Reserved, Set 0' })

        self.addChild(reserved)
        reserved.setFromInt(0)
        reserved.hide()

        cmdTaskChannel = register_class.cListDMTerminator(self.register,
                                        {'name' : 'Command Channel to use for Command or Task Slot',
                                         'offset' : 24,
                                         'bit length' : 2 })

        cmdTaskChannel.setMaxValue(2)
        cmdTaskChannel.setReportList(['CMD1 (0x08)', 'CMD2 (0x09)', 'CMD3 (0x1E)'])

        self.addChild(cmdTaskChannel)

        reserved = register_class.cForceSetDMTerminator( self.register,  { 'name' : 'Reserved',
                                                                'offset' : 26,
                                                                'bit length' : 6,
                                                                'force value' : int(0),
                                                                'force display' : 'Reserved, Set 0' })

        self.addChild(reserved)
        reserved.setFromInt(0)
        reserved.hide()


        AMEntryGPIOHighCmd = register_class.cDictDMTerminator(self.register,
                                        {'name' : 'Alt Mode Entry / GPIO High 4CC Command (not Task)',
                                         'offset' : 32,
                                         'bit length' : 32 })

        AMEntryGPIOHighCmd.setReportDict(cmdReportDict)


        self.addChild(AMEntryGPIOHighCmd)


        AMEntryGPIOHighCmdTsk = register_class.cDictDMTerminator(self.register,
                                        {'name' : 'Alt Mode Entry / GPIO High 4CC Command or Task',
                                         'offset' : 64,
                                         'bit length' : 32 })

        AMEntryGPIOHighCmdTsk.setReportDict(cmdTaskReportDict)


        self.addChild(AMEntryGPIOHighCmdTsk)

        AMEntryGPIOLowCmd = register_class.cDictDMTerminator(self.register,
                                        {'name' : 'Alt Mode Exit / GPIO Low 4CC Command (not Task)',
                                         'offset' : 96,
                                         'bit length' : 32 })

        AMEntryGPIOLowCmd.setReportDict(cmdReportDict)


        self.addChild(AMEntryGPIOLowCmd)


        AMExitGPIOLowCmdTsk = register_class.cDictDMTerminator(self.register,
                                        {'name' : 'Alt Mode Exit / GPIO Low 4CC Command or Task',
                                         'offset' : 128,
                                         'bit length' : 32 })

        AMExitGPIOLowCmdTsk.setReportDict(cmdTaskReportDict)


        self.addChild(AMExitGPIOLowCmdTsk)




class cMiscellaneous_0x5E_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Miscellaneous Configuration',
                                                 'address' : 0x5E,
                                                 'byte length' : 4,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Miscellaneous Configuration',
                                                        'offset' : 0,
                                                        'bit length' : 32 })

        hpdGpio = register_class.cForceSetDMTerminator( self,  { 'name' : 'DP Hot Plug Detect GPIO',
                                                                'offset' : 3,
                                                                'bit length' : 2,
                                                                'force value' : int(3),
                                                                'force display' : 'GPIO 4 is HPD Transmit and Receive'})

        hpdGpio.hide()
        self.dataModel.addChild(hpdGpio)
        hpdGpio.setFromInt(3)

        extRMReset = register_class.cForceSetDMTerminator( self,  { 'name' : 'External Reset from MReset',
                                                                'offset' : 8,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        extRMReset.hide()
        self.dataModel.addChild(extRMReset)
        extRMReset.setFromInt(1)

        extRPolarity = register_class.cForceSetDMTerminator( self,  { 'name' : 'External Reset Polarity',
                                                                'offset' : 9,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        extRPolarity.hide()
        self.dataModel.addChild(extRPolarity)
        extRPolarity.setFromInt(1)

        igCRCMis = register_class.cForceSetDMTerminator( self,  { 'name' : 'Ignore Good CRC Mismatch',
                                                                'offset' : 17,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        igCRCMis.hide()
        self.dataModel.addChild(igCRCMis)
        igCRCMis.setFromInt(0)


        Lock3V3 = register_class.cForceSetDMTerminator( self,  { 'name' : 'Lock 3V3 Output',
                                                                'offset' : 19,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        Lock3V3.hide()
        self.dataModel.addChild(Lock3V3)
        Lock3V3.setFromInt(1)

        I2C1Level3V3 = register_class.cForceSetDMTerminator( self,  { 'name' : 'Use 3V3 for I2C1 Level',
                                                                'offset' : 20,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : '3V3'})

        I2C1Level3V3.hide()
        self.dataModel.addChild(I2C1Level3V3)
        I2C1Level3V3.setFromInt(1)


        I2C2Level3V3 = register_class.cForceSetDMTerminator( self,  { 'name' : 'Use 3V3 for I2C2 Level',
                                                                'offset' : 21,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : '3V3'})

        I2C2Level3V3.hide()
        self.dataModel.addChild(I2C2Level3V3)
        I2C2Level3V3.setFromInt(1)




class cUserAMModeSettings(register_class.cDataModelArray) :
    def __init__(self, register, tier, iDict):
        register_class.cDataModelArray.__init__(self, register, tier, iDict)

        audEntryEnable = register_class.cBooleanDMTerminator(self.register,
                                                      {'name' : 'User VID Mode Autoentry Enabled',
                                                        'offset' : 0,
                                                        'bit length' : 1 })

        self.addChild(audEntryEnable)

        autoSendVdm = register_class.cBooleanDMTerminator(self.register,
                                        {'name' : 'Automatically Send VDM on Mode Entry',
                                         'offset' : 32,
                                         'bit length' : 1 })

        self.addChild(autoSendVdm)

        loadAppCfg = register_class.cBooleanDMTerminator(self.register,
                                        {'name' : 'Load App Config set On Mode Entry and Exit',
                                         'offset' : 64,
                                         'bit length' : 1 })

        self.addChild(loadAppCfg)




class cUserSvidConfig_0x4A_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'User Alternate Mode Config',
                                                 'address' : 0x4A,
                                                 'byte length' : 64,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name' : 'User Alternate Mode Config',
                                                        'offset' : 0,
                                                        'bit length' : 512 })

        enableFlags = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'General Settings',
                                                        'offset' : 0,
                                                        'bit length' : 24 })

        self.dataModel.addChild(enableFlags)



        vidEnable = register_class.cBooleanDMTerminator(self,
                                                      {'name' : 'User VID Enabled',
                                                        'offset' : 0,
                                                        'bit length' : 1 })

        enableFlags.addChild(vidEnable)

        uamVid = register_class.cHexDMTerminator(self,
                                                      {'name' : 'User Alternate Mode VID (Vendor ID)',
                                                        'offset' : 16,
                                                        'bit length' : 16 })

        enableFlags.addChild(uamVid)

        bbIndex = register_class.cHexDMTerminator(self,
                                                      {'name' : 'User Alternate Mode Billboard String Index',
                                                        'offset' : 8,
                                                        'bit length' : 8 })

        enableFlags.addChild(bbIndex)



        for i in range(4) :
            modeenable = register_class.cBooleanDMTerminator(self,
                                                          {'name' : 'User VID Mode %d Enabled' %(i+1),
                                                            'offset' : 32 + (i*8),
                                                            'bit length' : 1 })

            enableFlags.addChild(modeenable)

            userAmSettings = cUserAMModeSettings(self, 1,
                                        {'name' : 'User Alternate Mode #%d Settings' %(i+1),
                                         'offset' : 64 + (8*i),
                                         'bit length' : 416 })

            # we only have 3 app config sets, so hide app config checkbox for mode 4
            if i == 3 :
                userAmSettings.getChildByName('Load App Config set On Mode Entry and Exit').hide()

            modeNumber = register_class.cHexDMTerminator(self,
                                        {'name' : 'Mode Value',
                                         'offset' : 0,
                                         'bit length' : 32 })

            modeNumber.setFixedOffset(160 + (32 * i) )

            userAmSettings.prependChild(modeNumber)

            self.dataModel.addChild(userAmSettings)


        autoSendVdm = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Autosend VDM Data',
                                                        'offset' : 288,
                                                        'bit length' : 220 })

        self.dataModel.addChild(autoSendVdm)

        asVdoCount = register_class.cDecimalDMTerminator(self,
                                                      {'name' : 'Autosend VDM VDO Count',
                                                        'offset' : 208,
                                                        'bit length' : 3 })

        autoSendVdm.addChild(asVdoCount)

        for i in range(6) :
            asVdmData = register_class.cHexDMTerminator(self,
                                                          {'name' : 'Autosend VDM VDO %d Data' %(i+1),
                                                            'offset' : 32*i,
                                                            'bit length' : 32 })

            autoSendVdm.addChild(asVdmData)

        asVUseData = register_class.cHexDMTerminator(self,
                                                      {'name' : 'Autosend VDM Vendor Use Data',
                                                        'offset' : 192,
                                                        'bit length' : 16 })

        autoSendVdm.addChild(asVUseData)







# display pdos based on numPdo
# not a method, but should be grouped with txSrcCap class
def TxIDO_TopLevelDMGenerator(self) :
    numUfpIDO = self.getChildByName('Record Counts').getChildByName('Number of UFP Identity Objects').valueToInt()

    for i in range(6) :
        if i < numUfpIDO :
            self.getChildByName('UFP Discover Identity Response').dataModelChildrenArray[i].unhide()
        else :
            self.getChildByName('UFP Discover Identity Response').dataModelChildrenArray[i].hide()

    if numUfpIDO > 0 :
        self.getChildByName('UFP Discover Identity Response').unhide()
    else :
        self.getChildByName('UFP Discover Identity Response').hide()


    numTPIDO = self.getChildByName('Record Counts').getChildByName("Number of SOP' (Tethered Plug) Identity Objects").valueToInt()

    for i in range(6) :
        if i < numTPIDO :
            self.getChildByName("SOP' (Tethered Plug) Discover Identity Response").dataModelChildrenArray[i].unhide()
        else :
            self.getChildByName("SOP' (Tethered Plug) Discover Identity Response").dataModelChildrenArray[i].hide()

    if numTPIDO > 0 :
        self.getChildByName("SOP' (Tethered Plug) Discover Identity Response").unhide()
    else :
        self.getChildByName("SOP' (Tethered Plug) Discover Identity Response").hide()

    return self.childrenAsListDMGenerator()


class cTxIDO_0x47_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Transmit Identity Data Object',
                                                 'address' : 0x47,
                                                 'byte length' : 49,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name' : 'Transmit Identity Data Object',
                                                        'offset' : 0,
                                                        'bit length' : 392 })

        numIdoConfig = register_class.cDataModelArray(self, 1,
                                                      {'name' : 'Record Counts',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        numIdoConfig.hide()
        self.dataModel.addChild(numIdoConfig)


        numUfpIDO = register_class.cForceSetDMTerminator( self,  { 'name' : 'Number of UFP Identity Objects',
                                                                'offset' : 0,
                                                                'bit length' : 3,
                                                                'force value' : int(3),
                                                                'force display' : '3'})

        numUfpIDO.hide()
        numIdoConfig.addChild(numUfpIDO)
        numUfpIDO.setFromInt(3)


        numTPIDO = register_class.cForceSetDMTerminator( self,  { 'name' : "Number of SOP' (Tethered Plug) Identity Objects",
                                                                'offset' : 4,
                                                                'bit length' : 3,
                                                                'force value' : int(0),
                                                                'force display' : '0'})

        numTPIDO.hide()
        numIdoConfig.addChild(numTPIDO)
        numTPIDO.setFromInt(0)

        ufpIDO = register_class.cDataModelArray(self, 2,
                                                {'name' : 'UFP Discover Identity Response',
                                                 'offset' : 8,
                                                 'bit length' : 128 })


        self.dataModel.addChild(ufpIDO)
        ufpIDO.addChild(cUFPIDHeaderVDO(self, 1,
                                        {'name' : 'UFP IDO Header',
                                         'offset' : 0,
                                         'bit length' : 32 }))

        ufpIDO.addChild(register_class.cHexDMTerminator(self,
                                        {'name' : 'Certification Test ID',
                                         'offset' : 32,
                                         'bit length' : 20 }))

        ufpIDO.addChild(cUFPProductVDO(self, 1,
                                        {'name' : 'Product Vendor Defined Object',
                                         'offset' : 64,
                                         'bit length' : 32 }))

        ufpIDO.addChild(cAMAVDO(self, 1,
                                        {'name' : 'Alternate Mode Adapter VDO',
                                         'offset' : 96,
                                         'bit length' : 32 }))

        ufpIDO.addChild(register_class.cHexDMTerminator(self,
                                        {'name' : 'UFP IDO VDO #5',
                                         'offset' : 128,
                                         'bit length' : 32 }))

        ufpIDO.addChild(register_class.cHexDMTerminator(self,
                                        {'name' : 'UFP IDO VDO #6',
                                         'offset' : 160,
                                         'bit length' : 32 }))


        ufpIDO = register_class.cDataModelArray(self, 2,
                                                {'name' : "SOP' (Tethered Plug) Discover Identity Response",
                                                 'offset' : 200,
                                                 'bit length' : 128 })


        self.dataModel.addChild(ufpIDO)
        ufpIDO.addChild(cUFPIDHeaderVDO(self, 1,
                                        {'name' : "SOP' (Tethered Plug) IDO Header",
                                         'offset' : 0,
                                         'bit length' : 32 }))

        ufpIDO.addChild(register_class.cHexDMTerminator(self,
                                        {'name' : 'Certification Test ID',
                                         'offset' : 32,
                                         'bit length' : 20 }))

        ufpIDO.addChild(cUFPProductVDO(self, 1,
                                        {'name' : 'Product Vendor Defined Object',
                                         'offset' : 64,
                                         'bit length' : 32 }))

        ufpIDO.addChild(cCableVDO(self, 1,
                                        {'name' : 'Cable Vendor Defined Object',
                                         'offset' : 96,
                                         'bit length' : 32 }))

        ufpIDO.addChild(register_class.cHexDMTerminator(self,
                                        {'name' : "SOP' (Tethered Plug) IDO VDO #5",
                                         'offset' : 128,
                                         'bit length' : 32 }))

        ufpIDO.addChild(register_class.cHexDMTerminator(self,
                                        {'name' : "SOP' (Tethered Plug) IDO VDO #6",
                                         'offset' : 160,
                                         'bit length' : 32 }))



        self.dataModel.setDataModelGenerator(TxIDO_TopLevelDMGenerator)


class cDisplayPortCapabilities_0x51_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Display Port Capabilities',
                                                 'address' : 0x51,
                                                 'byte length' : 7,
                                                 'device' : device,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Display Port Capabilities',
                                                        'offset' : 0,
                                                        'bit length' : 56 })


        enDPSid = register_class.cBooleanDMTerminator(self,
                                                        {'name' : 'Enable Display Port SID',
                                                         'offset' : 0,
                                                         'bit length' : 1 })
        enDPSid.addUpdateRegisterByName('Alternate Mode Entry Queue')
        self.dataModel.addChild(enDPSid)

        enDPMode = register_class.cBooleanDMTerminator(self,
                                                        {'name' : 'Enable Display Port Mode 1',
                                                         'offset' : 1,
                                                         'bit length' : 1 })
        enDPMode.addUpdateRegisterByName('Alternate Mode Entry Queue')
        self.dataModel.addChild(enDPMode)

        portCap = register_class.cListDMTerminator(self,
                                                        {'name' : 'Port Capability',
                                                         'offset' : 8,
                                                         'bit length' : 2 })

        portCap.setReportList(['DP Disabled', 'DP UFP_D only', 'DP DFP_D only', 'DP UFP_D and DFP_D'])

        self.dataModel.addChild(portCap)


        signalling = register_class.cForceSetDMTerminator( self,  { 'name' : 'DisplayPort Signalling',
                                                                'offset' : 10,
                                                                'bit length' : 4,
                                                                'force value' : 1,
                                                                'force display' : 'DP 1.3'})

        self.dataModel.addChild(signalling)
        signalling.setFromInt(1)
        signalling.hide()



        receptIndic = register_class.cListDMTerminator(self,
                                                        {'name' : 'Receptacle Indication',
                                                         'offset' : 14,
                                                         'bit length' : 1 })

        receptIndic.setReportList(['Plug', 'Receptacle'])


        self.dataModel.addChild(receptIndic)


        usb2SNU = register_class.cForceSetDMTerminator( self,  { 'name' : 'USB2.0 Signalling Not Used',
                                                                'offset' : 15,
                                                                'bit length' : 1,
                                                                'force value' : 0,
                                                                'force display' : 'False'})

        self.dataModel.addChild(usb2SNU)
        usb2SNU.setFromInt(0)
        usb2SNU.hide()


#        dfpdpins = register_class.cMultiBooleanDMTerminator(self,
#                                                        {'name' : 'DFPD Receptacle or UFPD Plug Pin Assignment',
#                                                         'offset' : 16,
#                                                         'bit length' : 8 })
#        dfpdpins.setFlagNameList(['A', 'B', 'C', 'D', 'E', 'F'])
#        dfpdpins.setFlagMask([1, 1, 1, 1, 1, 1, 0, 0])
#        dfpdpins.setSpacing(6)
#        self.dataModel.addChild(dfpdpins)

        dfpdpins = register_class.cForceSetDMTerminator( self,  { 'name' : 'DFPD Receptacle or UFPD Plug Pin Assignment',
                                                                'offset' : 16,
                                                                'bit length' : 8,
                                                                'force value' : int(0x1C),
                                                                'force display' : 'C, D and E'})

        self.dataModel.addChild(dfpdpins)
        dfpdpins.setFromInt(0x1C)
        dfpdpins.hide()


#        ufpdpins = register_class.cMultiBooleanDMTerminator(self,
#                                                        {'name' : 'UFPD Receptacle or DFPD Plug Pin Assignment',
#                                                         'offset' : 24,
#                                                         'bit length' : 8 })
#
#        ufpdpins.setFlagNameList(['A', 'B', 'C', 'D', 'E', 'F'])
#        ufpdpins.setFlagMask([1, 1, 1, 1, 1, 0, 0, 0])
#        ufpdpins.setSpacing(6)
#        self.dataModel.addChild(ufpdpins)

        ufpdpins = register_class.cForceSetDMTerminator( self,  { 'name' : 'UFPD Receptacle or DFPD Plug Pin Assignment',
                                                                'offset' : 24,
                                                                'bit length' : 8,
                                                                'force value' : int(0xC),
                                                                'force display' : 'C and D'})

        self.dataModel.addChild(ufpdpins)
        ufpdpins.setFromInt(0xC)
        ufpdpins.hide()



        multiFunc = register_class.cBooleanDMTerminator(self,
                                                        {'name' : 'Multifunction Preferred',
                                                         'offset' : 32,
                                                         'bit length' : 1 })
        self.dataModel.addChild(multiFunc)



        muxSwap = register_class.cForceSetDMTerminator( self,  { 'name' : 'DisplayPort Mode Mux Swap',
                                                                'offset' : 33,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(muxSwap)
        muxSwap.setFromInt(0)
        muxSwap.hide()



        autoEnter = register_class.cForceSetDMTerminator( self,  { 'name' : 'DisplayPort Mode Auto Entry Allowed',
                                                                'offset' : 41,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(autoEnter)
        autoEnter.setFromInt(0)
        autoEnter.hide()


        billboardIndex = register_class.cForceSetDMTerminator( self,  { 'name' : 'Billboard Index',
                                                                'offset' : 48,
                                                                'bit length' : 8,
                                                                'force value' : int(6),
                                                                'force display' : '6'})

        self.dataModel.addChild(billboardIndex)
        billboardIndex.setFromInt(6)
        billboardIndex.hide()

class cIntVidConf_0x52_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Intel VID Config Register',
                                                 'address' : 0x52,
                                                 'byte length' : 8,
                                                 'device' : device,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 2,
                                                        {'name' : 'Intel VID Config Register',
                                                        'offset' : 0,
                                                        'bit length' : 64 })


        vidConfig = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Intel VID Config Set',
                                                        'offset' : 0,
                                                        'bit length' : 16 })

        self.dataModel.addChild(vidConfig)

        enIntVid = register_class.cBooleanDMTerminator(self,
                                                        {'name' : 'Enable Intel VID',
                                                         'offset' : 0,
                                                         'bit length' : 1 })

        enIntVid.addUpdateRegisterByName('Alternate Mode Entry Queue')
        vidConfig.addChild(enIntVid)


        enIntMode = register_class.cBooleanDMTerminator(self,
                                                        {'name' : 'Enable Intel Thunderbolt Mode',
                                                         'offset' : 1,
                                                         'bit length' : 1 })

        enIntMode.addUpdateRegisterByName('Alternate Mode Entry Queue')
        vidConfig.addChild(enIntMode)

        vout3V3R = register_class.cForceSetDMTerminator( self,  { 'name' : 'Vout_3V3 Required',
                                                                'offset' : 8,
                                                                'bit length' : 1,
                                                                'force value' : 1,
                                                                'force display' : 'Enabled'})

        self.dataModel.addChild(vout3V3R)
        vout3V3R.setFromInt(1)
        vout3V3R.hide()

        emarkOverride = register_class.cForceSetDMTerminator( self,  { 'name' : 'Thunderbolt Emarker Override',
                                                                'offset' : 9,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'False'})

        emarkOverride.hide()
        vidConfig.addChild(emarkOverride)
        emarkOverride.setFromInt(0)

        anMinPowerReq = register_class.cForceSetDMTerminator( self,  { 'name' : 'AN Minimum Power Required',
                                                                'offset' : 10,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'True'})

        anMinPowerReq.hide()
        vidConfig.addChild(anMinPowerReq)
        anMinPowerReq.setFromInt(1)


        adaptResponse = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Adapter Mode Response',
                                                        'offset' : 16,
                                                        'bit length' : 16 })

        adaptResponse.hide()
        self.dataModel.addChild(adaptResponse)

        legacyTBTAdapter = register_class.cForceSetDMTerminator( self,  { 'name' : 'Legacy TBT Adapter',
                                                                'offset' : 0,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'False'})

        legacyTBTAdapter.hide()
        adaptResponse.addChild(legacyTBTAdapter)
        legacyTBTAdapter.setFromInt(0)


        cableResponse = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Cable Mode Response',
                                                        'offset' : 32,
                                                        'bit length' : 16 })

        cableResponse.hide()
        self.dataModel.addChild(cableResponse)


        cableSpeed = register_class.cForceSetDMTerminator( self,  { 'name' : 'Cable Speed',
                                                                'offset' : 0,
                                                                'bit length' : 3,
                                                                'force value' : int(0),
                                                                'force display' : '0'})

        cableSpeed.hide()
        cableResponse.addChild(cableSpeed)
        cableSpeed.setFromInt(0)

        cableGen = register_class.cForceSetDMTerminator( self,  { 'name' : 'Cable Generation',
                                                                'offset' : 3,
                                                                'bit length' : 2,
                                                                'force value' : int(0),
                                                                'force display' : '0'})

        cableGen.hide()
        cableResponse.addChild(cableGen)
        cableGen.setFromInt(0)

        cableType = register_class.cForceSetDMTerminator( self,  { 'name' : 'Cable Type',
                                                                'offset' : 5,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : '0'})

        cableType.hide()
        cableResponse.addChild(cableType)
        cableType.setFromInt(0)

        cableActive = register_class.cForceSetDMTerminator( self,  { 'name' : 'Active Cable',
                                                                'offset' : 6,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : '0'})

        cableActive.hide()
        cableResponse.addChild(cableActive)
        cableActive.setFromInt(0)

        cableTraining = register_class.cForceSetDMTerminator( self,  { 'name' : 'Cable Training Supported',
                                                                'offset' : 7,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : '0'})

        cableTraining.hide()
        cableResponse.addChild(cableTraining)
        cableTraining.setFromInt(0)

        # we use the autoentry queue, not autoentry allowed flag
        tbtAutoentry = register_class.cForceSetDMTerminator( self,  { 'name' : 'Thunderbolt Mode Autoentry Allowed',
                                                                'offset' : 49,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        tbtAutoentry.hide()
        vidConfig.addChild(tbtAutoentry)
        tbtAutoentry.setFromInt(0)


        billboardIndex = register_class.cForceSetDMTerminator( self,  { 'name' : 'Billboard Index',
                                                                'offset' : 56,
                                                                'bit length' : 8,
                                                                'force value' : int(5),
                                                                'force display' : '5'})

        billboardIndex.hide()
        vidConfig.addChild(billboardIndex)
        billboardIndex.setFromInt(5)

class cTIVidConf_0x54_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Texas Instruments VID Config',
                                                 'address' : 0x54,
                                                 'byte length' : 12,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Texas Instruments VID Config',
                                                        'offset' : 0,
                                                        'bit length' : 96 })

        enTIVid = register_class.cBooleanDMTerminator(self,
                                                        {'name' : 'Enable Texas Instruments VID',
                                                         'offset' : 0,
                                                         'bit length' : 1 })
        self.dataModel.addChild(enTIVid)

        enPDIOMode = register_class.cBooleanDMTerminator(self,
                                                        {'name' : 'Enable PDIO Mode',
                                                         'offset' : 1,
                                                         'bit length' : 1 })
        self.dataModel.addChild(enPDIOMode)


#        enQuickswapMode = register_class.cBooleanDMTerminator(self,
#                                                        {'name' : 'Enable Quickswap Mode',
#                                                         'offset' : 2,
#                                                         'bit length' : 1 })
#        self.dataModel.addChild(enQuickswapMode)

        enPDIOAutoentry = register_class.cBooleanDMTerminator(self,
                                                        {'name' : 'Enable PDIO Mode Autoentry',
                                                         'offset' : 9,
                                                         'bit length' : 1 })
        self.dataModel.addChild(enPDIOAutoentry)


#        enQuickswapAutoentry = register_class.cBooleanDMTerminator(self,
#                                                        {'name' : 'Enable Quickswap Mode Autoentry',
#                                                         'offset' : 10,
#                                                         'bit length' : 1 })
#        self.dataModel.addChild(enQuickswapAutoentry)

        messageIndex = register_class.cDataModelTerminator(self,
                                                        {'name' : 'Message Index',
                                                         'offset' : 16,
                                                         'bit length' : 8 })
        self.dataModel.addChild(messageIndex)

        pdioSignature = register_class.cDataModelTerminator(self,
                                                        {'name' : 'PDIO Signature',
                                                         'offset' : 32,
                                                         'bit length' : 32 })
        self.dataModel.addChild(pdioSignature)

#        quickswapSignature = register_class.cDataModelTerminator(self,
#                                                        {'name' : 'Quickswap Signature',
#                                                         'offset' : 64,
#                                                         'bit length' : 32 })
#        self.dataModel.addChild(quickswapSignature)


# since the entire register is forced values, hide at the template level

class cPolicySettings_0x55_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Policy Settings',
                                                 'address' : 0x55,
                                                 'byte length' : 1,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Policy Settings',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        enVSafe0v = register_class.cForceSetDMTerminator( self,  { 'name' : 'Set VSafe0V to 2V for Disconnect Detection',
                                                                'offset' : 0,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(enVSafe0v)
        enVSafe0v.setFromInt(1)

        enGoodCRCNonPref = register_class.cForceSetDMTerminator( self,  { 'name' : 'Use Non-preferred Specification Revision Bits in Good CRC Message',
                                                                'offset' : 1,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'Disabled'})

        self.dataModel.addChild(enGoodCRCNonPref)
        enGoodCRCNonPref.setFromInt(1)



class cSleepControl_0x70_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'Sleep Control Register',
                                                 'address' : 0x70,
                                                 'byte length' : 2,
                                                 'permission' : 'RW'})

        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Sleep Control Register',
                                                        'offset' : 0,
                                                        'bit length' : 16 })

        sleepMode = register_class.cForceSetDMTerminator( self,  { 'name' : 'Sleep Mode Allowed',
                                                                'offset' : 0,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'Enabled'})

        self.dataModel.addChild(sleepMode)
        sleepMode.setFromInt(1)


        delay100ms = register_class.cForceSetDMTerminator( self,  { 'name' : 'Delay 100 mS Before Sleep',
                                                                'offset' : 1,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'False'})

        self.dataModel.addChild(delay100ms)
        delay100ms.setFromInt(0)


        delay1000ms = register_class.cForceSetDMTerminator( self,  { 'name' : 'Delay 1000 mS Before Sleep',
                                                                'offset' : 2,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'True'})

        self.dataModel.addChild(delay1000ms)
        delay1000ms.setFromInt(1)

        delay30000ms = register_class.cForceSetDMTerminator( self,  { 'name' : 'Delay 30000 mS Before Sleep',
                                                                'offset' : 4,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'False'})

        self.dataModel.addChild(delay30000ms)
        delay30000ms.setFromInt(0)



        sleepon5Vnonpd = register_class.cForceSetDMTerminator( self,  { 'name' : 'Sleep on 5V non-PD Load',
                                                                'offset' : 3,
                                                                'bit length' : 1,
                                                                'force value' : int(1),
                                                                'force display' : 'True'})

        self.dataModel.addChild(sleepon5Vnonpd)
        sleepon5Vnonpd.setFromInt(1)

        sleeponpdconn = register_class.cForceSetDMTerminator( self,  { 'name' : 'Sleep on PD connected load',
                                                                'offset' : 5,
                                                                'bit length' : 1,
                                                                'force value' : int(0),
                                                                'force display' : 'False'})

        self.dataModel.addChild(sleeponpdconn)
        sleeponpdconn.setFromInt(0)

        I2Crelaxresp = register_class.cForceSetDMTerminator( self,  { 'name' : 'I2C Relax Response Level',
                                                                'offset' : 8,
                                                                'bit length' : 8,
                                                                'force value' : int(4),
                                                                'force display' : 'S4'})

        self.dataModel.addChild(I2Crelaxresp)
        I2Crelaxresp.setFromInt(4)


class cGPIOStatus_0x72_register(register_class.cRegister) :
    def __init__(self):
        register_class.cRegister.__init__(self, {'register name' : 'GPIO Status Register',
                                                 'address' : 0x72,
                                                 'byte length' : 8,
                                                 'permission' : 'DRO'})

        # Should permissions be DRO?
        self.dataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'GPIO Status Register',
                                                        'offset' : 0,
                                                        'bit length' : 64 })

        for i in range(22):
            GPIO = register_class.cHexDMTerminator(self,
                                                    {'name' : 'GPIO%d Data' %(i) ,
                                                     'offset' : i,
                                                     'bit length' : 1 })
            GPIO.help = """Logic status of GPIO[%d] \n0 - Low \n1 - High""" %(i)
            self.dataModel.addChild(GPIO)


        for i in range(22):
            GPIODir = register_class.cHexDMTerminator(self,
                                                    {'name' : 'GPIO%d Direction' %(i) ,
                                                     'offset' : 32+i,
                                                     'bit length' : 1 })
            GPIODir.help = """Direction of GPIO%d \n0 - Input \n1 - Output""" %(i)
            self.dataModel.addChild(GPIODir)



# host interface function list

task_return_dict = { 0x00000000 : 'SUCCESS_CMD', 0x00000001 : 'ABORT_CMD', 0x00000003 : 'REJECT_CMD' }

class cPDOCurrentField(register_class.cScalingDMTerminator) :
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'' : 0.01, 'A' : 0.01, 'mA' : 10.0}
        self.defaultUnit = 'A'


class cPDOVoltageField(register_class.cScalingDMTerminator) :
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'' : 0.05, 'V' : 0.05, 'mV' : 50.0}
        self.defaultUnit = 'V'

class cPDOPowerField(register_class.cScalingDMTerminator) :
    def __init__(self, register, iDict):
        register_class.cScalingDMTerminator.__init__(self, register, iDict)
        # map all strings representing units to scale factor
        self.dictScaleUnits = {'' : 0.25, 'W' : 0.25, 'mW' : 250.0}
        self.defaultUnit = 'W'


class cDBfg(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Deadbattery Flag Clear',
                                                 '4cc' : 'DBfg',
                                                 'inargs byte length' : 0,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = None
        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)


class cABRT(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Abort',
                                                 '4cc' : 'ABRT',
                                                 'inargs byte length' : 0,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = None
        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)


class cGaid(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Warm Reboot',
                                                 '4cc' : 'Gaid',
                                                 'inargs byte length' : 0,
                                                 'outargs byte length' : 0})

        self.inargsDataModel = None
        self.outargsDataModel = None


class cGAID(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Cold Reboot',
                                                 '4cc' : 'GAID',
                                                 'inargs byte length' : 0,
                                                 'outargs byte length' : 0})

        self.inargsDataModel = None
        self.outargsDataModel = None


class cHRST(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'PD Hard Reset',
                                                 '4cc' : 'HRST',
                                                 'inargs byte length' : 0,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = None
        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)


class cCRST(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Cable Reset',
                                                 '4cc' : 'CRST',
                                                 'inargs byte length' : 0,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = None
        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)


class cGSkC(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Get Sink Capabilities',
                                                 '4cc' : 'GSkC',
                                                 'inargs byte length' : 0,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = None
        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)


class cGSrC(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Get Source Capabilities',
                                                 '4cc' : 'GSrC',
                                                 'inargs byte length' : 0,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = None
        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)


class cSSrC(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Send Source Capabilities',
                                                 '4cc' : 'SSrC',
                                                 'inargs byte length' : 0,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = None
        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)


class cSRDO(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Send Request Data Object',
                                                 '4cc' : 'SRDO',
                                                 'inargs byte length' : 4,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = register_class.cDataModelArray(self, 1,
                                                        {'name' : 'Input Arguments',
                                                        'offset' : 0,
                                                        'bit length' : 32 })


        mmOpCurr = cPDOCurrentField(self.inargsMiniReg, { 'name' : 'Max/Min Operating Current or Power',
                                                                'offset' : 0,
                                                                'bit length' : 10} )
        self.inargsDataModel.addChild(mmOpCurr)

        opCurr = cPDOCurrentField(self.inargsMiniReg, { 'name' : 'Operating Current or Power',
                                                                'offset' : 10,
                                                                'bit length' : 10} )
        self.inargsDataModel.addChild(opCurr)

        noUSBSusp = register_class.cBooleanDMTerminator(self.inargsMiniReg, { 'name' : 'No USB Suspend',
                                                                'offset' : 24,
                                                                'bit length' : 1} )
        self.inargsDataModel.addChild(noUSBSusp)

        USBCommCap = register_class.cBooleanDMTerminator(self.inargsMiniReg, { 'name' : 'USB Communications Capable',
                                                                'offset' : 25,
                                                                'bit length' : 1} )
        self.inargsDataModel.addChild(USBCommCap)

        capMismatch = register_class.cBooleanDMTerminator(self.inargsMiniReg, { 'name' : 'Capability Mismatch',
                                                                'offset' : 26,
                                                                'bit length' : 1} )
        self.inargsDataModel.addChild(capMismatch)

        giveBack = register_class.cBooleanDMTerminator(self.inargsMiniReg, { 'name' : 'Give Back Flag',
                                                                'offset' : 27,
                                                                'bit length' : 1} )
        self.inargsDataModel.addChild(giveBack)

        objPosn = register_class.cDecimalDMTerminator(self.inargsMiniReg, { 'name' : 'Object Position',
                                                                'offset' : 28,
                                                                'bit length' : 3} )
        self.inargsDataModel.addChild(objPosn)



        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)



class cSWSk(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Swap to Sink',
                                                 '4cc' : 'SWSk',
                                                 'inargs byte length' : 0,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = None
        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)


class cSWSr(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Swap to Source',
                                                 '4cc' : 'SWSr',
                                                 'inargs byte length' : 0,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = None
        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)



class cSWDF(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Swap to DFP',
                                                 '4cc' : 'SWDF',
                                                 'inargs byte length' : 0,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = None
        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)



class cSWUF(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Swap to UFP',
                                                 '4cc' : 'SWUF',
                                                 'inargs byte length' : 0,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = None
        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)



class cSWVC(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Swap VConn Provider',
                                                 '4cc' : 'SWVC',
                                                 'inargs byte length' : 0,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = None
        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)


class cSRDY(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'System Ready to Sink Power',
                                                 '4cc' : 'SRDY',
                                                 'inargs byte length' : 1,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                        {'name' : 'Input Arguments',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        swSel = register_class.cListDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'Switch Selection',
                                                            'offset' : 0,
                                                            'bit length' : 2 })
        swSel.setReportList(self.SwitchSelection_list)
        swSel.setMaxValue(2)
        self.inargsDataModel.addChild(swSel)


        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)

    SwitchSelection_list = ['Reserved', 'PP_HV', 'PP_HVE']


class cAMEn(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Enter Alternate Mode',
                                                 '4cc' : 'AMEn',
                                                 'inargs byte length' : 5,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                        {'name' : 'Input Arguments',
                                                        'offset' : 0,
                                                        'bit length' : 40 })

        SVID = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'SVID',
                                                            'offset' : 0,
                                                            'bit length' : 32 })
        self.inargsDataModel.addChild(SVID)

        objPosn = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'Object Position',
                                                            'offset' : 32,
                                                            'bit length' : 3 })
        self.inargsDataModel.addChild(objPosn)


        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)



class cAMEx(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Exit Alternate Mode',
                                                 '4cc' : 'AMEx',
                                                 'inargs byte length' : 5,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                        {'name' : 'Input Arguments',
                                                        'offset' : 0,
                                                        'bit length' : 40 })

        SVID = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'SVID',
                                                            'offset' : 0,
                                                            'bit length' : 32 })
        self.inargsDataModel.addChild(SVID)

        objPosn = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'Object Position',
                                                            'offset' : 32,
                                                            'bit length' : 3 })
        self.inargsDataModel.addChild(objPosn)


        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)



class cANEG(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Autonegotiate Sink',
                                                 '4cc' : 'ANEG',
                                                 'inargs byte length' : 0,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = None
        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)


class cAMDs(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Start Alternate Mode Discovery',
                                                 '4cc' : 'AMDs',
                                                 'inargs byte length' : 0,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = None
        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)


class cGPie(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Enable GPIO as Input',
                                                 '4cc' : 'GPie',
                                                 'inargs byte length' : 1,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                        {'name' : 'Input Arguments',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        gpioNum = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'GPIO Number',
                                                            'offset' : 0,
                                                            'bit length' : 8 })
        gpioNum.setMaxValue(21)
        self.inargsDataModel.addChild(gpioNum)


        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)


class cGPoe(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Enable GPIO as Output',
                                                 '4cc' : 'GPoe',
                                                 'inargs byte length' : 1,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                        {'name' : 'Input Arguments',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        gpioNum = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'GPIO Number',
                                                            'offset' : 0,
                                                            'bit length' : 8 })
        gpioNum.setMaxValue(21)
        self.inargsDataModel.addChild(gpioNum)


        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)



class cGPsh(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Set GPIO High',
                                                 '4cc' : 'GPsh',
                                                 'inargs byte length' : 1,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                        {'name' : 'Input Arguments',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        gpioNum = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'GPIO Number',
                                                            'offset' : 0,
                                                            'bit length' : 8 })
        gpioNum.setMaxValue(21)
        self.inargsDataModel.addChild(gpioNum)


        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)



class cGPsl(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Set GPIO Low',
                                                 '4cc' : 'GPsl',
                                                 'inargs byte length' : 1,
                                                 'outargs byte length' : 1})

        self.inargsDataModel = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                        {'name' : 'Input Arguments',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        gpioNum = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'GPIO Number',
                                                            'offset' : 0,
                                                            'bit length' : 8 })
        gpioNum.setMaxValue(21)
        self.inargsDataModel.addChild(gpioNum)


        self.outargsDataModel = register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)

# display pdos based on numPdo
# not a method, but should be grouped with txSrcCap class
def VDMs_inargs_TopLevelDMGenerator(self) :
    numVdo = self.getChildByName('Number of 32-bit VDM Objects').valueToInt()

    for i in range(7) :
        if i < numVdo :
            self.getChildByName('VDO %d Payload (32-bit)' %(i+1)).unhide()
        else :
            self.getChildByName('VDO %d Payload (32-bit)' %(i+1)).hide()

    return self.childrenAsListDMGenerator()

class cVDMs(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'Send VDM Packet',
                                                 '4cc' : 'VDMs',
                                                 'inargs byte length' : 1,
                                                 'outargs byte length' : 1})

        self.setInputModel ( register_class.cDataModelArray(self.inargsMiniReg, 2,
                                                        {'name' : 'Input Arguments',
                                                        'offset' : 0,
                                                        'bit length' : 8 }) )

        self.inargsArray = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                        {'name' : 'Input Arguments',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        self.inargsDataModel.addChild(self.inargsArray)

        numObj = register_class.cDecimalDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'Number of 32-bit VDM Objects',
                                                            'offset' : 0,
                                                            'bit length' : 3 })
        numObj.setMaxValue(7)
        numObj.addUpdateRegisterByName('self')
        self.inargsArray.addChild(numObj)

        sopType = register_class.cListDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'SOP Type',
                                                            'offset' : 4,
                                                            'bit length' : 2 })
        sopType.setReportList(self.sop_type_list)
        sopType.setMaxValue(2)
        self.inargsArray.addChild(sopType)

        structType = register_class.cListDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'Structured/Unstructured',
                                                            'offset' : 23,
                                                            'bit length' : 1 })
        structType.setReportList(self.structured_type_list)
        self.inargsArray.addChild(structType)

        SVID = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'SVID (Standard or Vendor ID)',
                                                            'offset' : 24,
                                                            'bit length' : 16 })
        self.inargsArray.addChild(SVID)

        vdo0 = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'VDO 0 Partial Payload (15-bit)',
                                                            'offset' : 8,
                                                            'bit length' : 15 })
        self.inargsArray.addChild(vdo0)


        for i in range(1,8) :
            vdox = register_class.cHexDMTerminator(self.inargsMiniReg,
                                                              {'name' : 'VDO %d Payload (32-bit)' %i,
                                                                'offset' : 8 + (32 * i),
                                                                'bit length' : 32 })
            self.inargsArray.addChild(vdox)


        self.inargsArray.setDataModelGenerator(VDMs_inargs_TopLevelDMGenerator)

        self.setOutputModel( register_class.cDataModelArray(self.outargsMiniReg, 2,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 8 }))

        TSKReturn = register_class.cDictDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Task Return Status',
                                                            'offset' : 0,
                                                            'bit length' : 8 })

        TSKReturn.setReportDict(task_return_dict)
        TSKReturn.lock()
        self.outargsDataModel.addChild(TSKReturn)


    sop_type_list = ['SOP', 'SOP Prime', 'SOP Double-Prime']
    structured_type_list = ['Unstructured VDM', 'Structured VDM']


ADCchannelListOfDict = [ { 'Channel' : 'Thermal Sensor Temperature', 'Divider Ratio' : 1024 / 1.2, 'Unit' : 'Raw (1024 LSB scale)' }, \
    { 'Channel' : 'VBUS Voltage', 'Divider Ratio' : 25, 'Unit' : 'V' }, \
    { 'Channel' : 'SENSEP', 'Divider Ratio' : 25, 'Unit' : 'V' }, \
    { 'Channel' : 'PP_EXT Current', 'Divider Ratio' : 5, 'Unit' : 'A' }, \
    { 'Channel' : 'PP_HV Voltage', 'Divider Ratio' : 25, 'Unit' : 'V' }, \
    { 'Channel' : 'PP_HV Current', 'Divider Ratio' : 3, 'Unit' : 'A' }, \
    { 'Channel' : 'PP 5V Voltage', 'Divider Ratio' : 5, 'Unit' : 'V' }, \
    { 'Channel' : 'PP_5V Current', 'Divider Ratio' : 3, 'Unit' : 'A' }, \
    { 'Channel' : 'CC1 Voltage (divide by 5)', 'Divider Ratio' : 5, 'Unit' : 'V' }, \
    { 'Channel' : 'I_CC', 'Divider Ratio' : 0.7, 'Unit' : 'V' }, \
    { 'Channel' : 'CC2 Voltage (divide by 5)', 'Divider Ratio' : 5, 'Unit' : 'V' }, \
    { 'Channel' : 'GPIO 5', 'Divider Ratio' : 1, 'Unit' : 'V' }, \
    { 'Channel' : 'CC1 Voltage (divide by 2)', 'Divider Ratio' : 2, 'Unit' : 'V' }, \
    { 'Channel' : 'CC2 Voltage (divide by 2)', 'Divider Ratio' : 2, 'Unit' : 'V' }, \
    { 'Channel' : 'PP_Cable', 'Divider Ratio' : 5, 'Unit' : 'V' }, \
    { 'Channel' : 'VIN_3V3', 'Divider Ratio' : 3, 'Unit' : 'V' }, \
    { 'Channel' : 'VOUT_3V3', 'Divider Ratio' : 3, 'Unit' : 'V' }, \
    { 'Channel' : 'Brick ID', 'Divider Ratio' : 3, 'Unit' : 'V' }, \
    { 'Channel' : 'V1P8D', 'Divider Ratio' : 2, 'Unit' : 'V' }, \
    { 'Channel' : 'V1P8A', 'Divider Ratio' : 2, 'Unit' : 'V' }, \
    { 'Channel' : 'V3P3', 'Divider Ratio' : 3, 'Unit' : 'V' }, \
    { 'Channel' : 'I2CADDR', 'Divider Ratio' : 3, 'Unit' : 'V' }, \
    { 'Channel' : 'GPIO_0', 'Divider Ratio' : 3, 'Unit' : 'V' }, \
    { 'Channel' : 'GPIO_1', 'Divider Ratio' : 3, 'Unit' : 'V' }, \
    { 'Channel' : 'GPIO_2', 'Divider Ratio' : 3, 'Unit' : 'V' }, \
    { 'Channel' : 'GPIO_3', 'Divider Ratio' : 3, 'Unit' : 'V' }, \
    { 'Channel' : 'GPIO_4', 'Divider Ratio' : 3, 'Unit' : 'V' }, \
    { 'Channel' : 'GPIO_5', 'Divider Ratio' : 3, 'Unit' : 'V' }, \
    { 'Channel' : 'GPIO_6', 'Divider Ratio' : 3, 'Unit' : 'V' }, \
    { 'Channel' : 'GPIO_7', 'Divider Ratio' : 3, 'Unit' : 'V' }, \
    { 'Channel' : 'GPIO_8', 'Divider Ratio' : 3, 'Unit' : 'V' }, \
    { 'Channel' : 'BUSPOWER_Z', 'Divider Ratio' : 3, 'Unit' : 'V' }, \
    ]


class cDMAnyChannelTerminator(register_class.cDataModelTerminator) :
    def __init__(self, register, adcFunction, iDict):
        register_class.cDataModelTerminator.__init__(self, register, iDict)
        self.adcFunction = adcFunction
        self.terminatorOverlayList = []

        for channel in ADCchannelListOfDict :
            channelTerm = register_class.cScalingDMTerminator(self.register,
                                                          {'name' : iDict['name'],
                                                            'offset' : iDict['offset'],
                                                            'bit length' : iDict['bit length'] })
            ratio = ( (1.2) / 1024 ) * channel['Divider Ratio']
            channelTerm.dictScaleUnits = {'' : ratio, channel['Unit'] : ratio}
            channelTerm.defaultUnit = channel['Unit']

            self.terminatorOverlayList.append(channelTerm)


        self.dataModelGenerator = self.AnyScalerGenerator


    def AnyScalerGenerator(self):
        # todo: should make a set parent call instead of allowing to be set directly
        #       then the objects can correctly set sub-object parent relationships
        for term in self.terminatorOverlayList :
            term.parent = self.parent

        channel = self.adcFunction.inargsDataModel.getChildByName('Channel').valueToInt()
        dmGenerator = self.terminatorOverlayList[channel]

        return dmGenerator.dataModelGenerator()

    def lock(self) :
        for term in self.terminatorOverlayList :
            term.lock()


class cADCs(function_class.cFunction) :
    def __init__(self):
        function_class.cFunction.__init__(self, {'function name' : 'ADC Read',
                                                 '4cc' : 'ADCs',
                                                 'inargs byte length' : 1,
                                                 'outargs byte length' : 3})



        self.channelList = []
        for record in ADCchannelListOfDict :
            self.channelList.append(record['Channel'])

        inargsDM = register_class.cDataModelArray(self.inargsMiniReg, 1,
                                                        {'name' : 'Input Arguments',
                                                        'offset' : 0,
                                                        'bit length' : 8 })

        channel = register_class.cListDMTerminator(self.inargsMiniReg,
                                                          {'name' : 'Channel',
                                                            'offset' : 0,
                                                            'bit length' : 5 })
        channel.setReportList(self.channelList)
        channel.setMaxValue(23)
        inargsDM.addChild(channel)

        self.setInputModel(inargsDM)


        outargsDM = register_class.cDataModelArray(self.outargsMiniReg, 1,
                                                        {'name' : 'Return Values',
                                                        'offset' : 0,
                                                        'bit length' : 24 })

        channelRead = register_class.cListDMTerminator(self.outargsMiniReg,
                                                          {'name' : 'Channel',
                                                            'offset' : 0,
                                                            'bit length' : 5 })
        channelRead.setReportList(self.channelList)
        channelRead.setMaxValue(23)
        outargsDM.addChild(channelRead)
        channelRead.lock()

        TSKReturn = cDMAnyChannelTerminator(self.outargsMiniReg, self,
                                                          {'name' : 'ADC Read Value',
                                                            'offset' : 8,
                                                            'bit length' : 10 })

        TSKReturn.lock()
        outargsDM.addChild(TSKReturn)

        self.setOutputModel(outargsDM)


templateDevice = "TPS65982"
templateVersion = "2.14"

# String Table Definitions
stringTableListofDict = [ {'name' : 'iSerialNumber', 'default' : '01.00.00'}, \
                {'name' : 'iProduct', 'default' : 'TPS65982'}, \
                {'name' : 'iManufacturer', 'default' : 'Texas Instruments'}, \
                {'name' : 'iAdditionalInfoURL', 'default' : 'http://www.ti.com/product/TPS65982'}, \
                {'name' : 'TBT string', 'default' : 'Thunderbolt Mode Entry Error'}, \
                {'name' : 'DP string', 'default' : 'HTTP://help.vesa.org/dp-usb-type-c'} ]


hideShareConfigs = True
hideNumDevices = True

zeroOneList = [ '0', '1' ]
i2cAddrList = [ '0 (0 Ohm R_d)', \
                '1 (93.1 KOhm R_d)', \
                '2 (156 KOhm R_d)', \
                '3 (220 KOhm R_d)', \
                '4 (280 KOhm R_d)', \
                '5 (340 KOhm R_d)', \
                '6 (402 KOhm R_d)', \
                '7 (Open)', \
              ]

def dbg1ValueFromAddr(strapping) :
    return (strapping >> 4) & 0x1

def dbg2ValueFromAddr(strapping) :
    return (strapping >> 3) & 0x1

def i2cAddrValueFromAddr(strapping) :
    return (strapping) & 0x7

def indexOfName(name, deviceStrappingValuesListOfDict) :
    for (i, record) in enumerate(deviceStrappingValuesListOfDict) :
        if record['name'] == name :
            return i

    return None

def tps65982_addr_function(portNum, deviceStrappingValuesListOfDict) :
    dbg1Value = deviceStrappingValuesListOfDict[indexOfName('DBG_CTL1', deviceStrappingValuesListOfDict)]['value']
    dbg2Value = deviceStrappingValuesListOfDict[indexOfName('DBG_CTL2', deviceStrappingValuesListOfDict)]['value']
    i2cAddrValue = deviceStrappingValuesListOfDict[indexOfName('I2C_ADDR', deviceStrappingValuesListOfDict)]['value']

    assert portNum == 0

    addr = 0
    addr |= dbg1Value << 4
    addr |= dbg2Value << 3
    addr |= i2cAddrValue

    return addr
# 1-byte selection bitfield if 3 bits in address
# 4-byte selection bitfield if 5 bits in address
numBitsDeviceAddress = 5

def tps65983_addr_function_i2c1(portNum, deviceStrappingValuesListOfDict) :
    index = indexOfName('DBG_CTL1', deviceStrappingValuesListOfDict)
    if index == None :
        dbg1Value = 0
    else :
        dbg1Value = deviceStrappingValuesListOfDict[index]['value']

    index = indexOfName('DBG_CTL2', deviceStrappingValuesListOfDict)
    if index == None :
        dbg2Value = 0
    else :
        dbg2Value = deviceStrappingValuesListOfDict[index]['value']

    index = indexOfName('I2C_ADDR', deviceStrappingValuesListOfDict)
    if index == None :
        i2cAddrValue = 0
    else :
        i2cAddrValue = deviceStrappingValuesListOfDict[index]['value']

    addr = 0
    addr |= dbg1Value << 4
    addr |= dbg2Value << 3
    addr |= i2cAddrValue
    addr |= portNum << 2

    addr |= 0x38

    return addr


def tps65983_addr_function_i2c2(portNum, deviceStrappingValuesListOfDict) :
    index = indexOfName('DBG_CTL1', deviceStrappingValuesListOfDict)
    if index == None :
        dbg1Value = 0
    else :
        dbg1Value = deviceStrappingValuesListOfDict[index]['value']

    index = indexOfName('DBG_CTL2', deviceStrappingValuesListOfDict)
    if index == None :
        dbg2Value = 0
    else :
        dbg2Value = deviceStrappingValuesListOfDict[index]['value']

    index = indexOfName('I2C_ADDR', deviceStrappingValuesListOfDict)
    if index == None :
        i2cAddrValue = 0
    else :
        i2cAddrValue = deviceStrappingValuesListOfDict[index]['value']

    addr = 0
    addr |= dbg1Value << 4
    addr |= dbg2Value << 3
    addr |= i2cAddrValue
    addr |= portNum << 2

    addr |= 0x20

    return addr



deviceStrappingListOfDict = [ \
                    {'name' : 'DBG_CTL1', 'type' : 'pulldown', 'option list' : zeroOneList, 'value function' : dbg1ValueFromAddr }, \
                    {'name' : 'DBG_CTL2', 'type' : 'pulldown', 'option list' : zeroOneList, 'value function' : dbg2ValueFromAddr }, \
                    {'name' : 'I2C_ADDR', 'type' : 'pulldown', 'option list' : i2cAddrList, 'value function' : i2cAddrValueFromAddr }, \
                ]

devicePortsListOfDict = [ \
                {'name' : 'Port1', 'port value' : 0 , 'addr function' : tps65982_addr_function, 'addr function I2C1' : tps65983_addr_function_i2c1, 'addr function I2C2' : tps65983_addr_function_i2c2 }, \
                ]


virtualStrappingListOfDict = [ \
                    {'name' : 'DBG_CTL1', 'type' : 'pulldown', 'option list' : zeroOneList, 'value function' : dbg1ValueFromAddr }, \
                    {'name' : 'DBG_CTL2', 'type' : 'pulldown', 'option list' : zeroOneList, 'value function' : dbg2ValueFromAddr }, \
                    {'name' : 'I2C_ADDR', 'type' : 'pulldown', 'option list' : i2cAddrList, 'value function' : i2cAddrValueFromAddr }, \
                ]

virtualPortsListOfDict = [ \
                {'name' : 'Port1', 'port value' : 0 , 'addr function' : tps65982_addr_function }, \
                ]


# device definitions
allAceDevice = register_class.cDevice({'I2C address' : 0x38, 'ports' : devicePortsListOfDict, 'strapping' : deviceStrappingListOfDict})
allAceDevice.addRegister(cCustUse_0x06_register())
allAceDevice.configureDerivedFields()
allAceDevice.hide()

NUM_PHYSICAL_DEVICES = 2
oneAceDeviceList = []
for i in range(NUM_PHYSICAL_DEVICES) :
    device = register_class.cDevice({'I2C address' : 0x38, 'ports' : devicePortsListOfDict, 'strapping' : deviceStrappingListOfDict})
    device.addRegister(cMode_0x03_register())
    device.addRegister(cMode_0x03_register())
    device.addRegister(cCustUse_0x06_register())
    Mask1 = cIntMask1_0x16_register()
    Mask1.hide()
    device.addRegister(Mask1)
    Mask2 = cIntMask2_0x17_register()
    Mask2.hide()
    device.addRegister(Mask2)
    device.addRegister(cStatus_0x1A_register())
    device.addRegister(cSysConfig_0x28_register())
    device.addRegister(cControlConfig_0x29_register())
    device.addRegister(cRxSrcCap_0x30_register())
    device.addRegister(cRxSinkCap_0x31_register())
    device.addRegister(cTxSrcCap_0x32_register())
    device.addRegister(cTxSinkCap_0x33_register())
    device.addRegister(cActiveContractPDO_0x34_register())
    device.addRegister(cActiveContractRDO_0x35_register())
    ANeg = cAutoNegSink_0x37_register()
    ANeg.hide()
    device.addRegister(ANeg)
    AMQueue = cAltModeEntryQueue_0x38_register()
    AMQueue.hide()
    device.addRegister(AMQueue)
    device.addRegister(cPowerStatus_0x3F_register())
    device.addRegister(cPDStatus_0x40_register())
    device.addRegister(cTxIDO_0x47_register())
    # have to pass device to DP and TBT registers so they can find AltModeEntryQueue to update it
    device.addRegister(cDisplayPortCapabilities_0x51_register())
    device.addRegister(cDPSIDStatus_0x58_register())
    device.addRegister(cIntVidConf_0x52_register())
    device.addRegister(cIntelVIDStatus_0x59_register())
    device.addRegister(cGPIOEventMap_0x5C_register())
    device.addRegister(cGPIOEventMap_0x5D_register())
    device.addRegister(cGPIOStatus_0x72_register())
    miscReg = cMiscellaneous_0x5E_register()
    miscReg.hide()
    device.addRegister(miscReg)
    sleepCtl = cSleepControl_0x70_register()
    sleepCtl.hide()
    device.addRegister(sleepCtl)

    device.addHIFunction(function_class.cRawRead())
    device.addHIFunction(function_class.cRawWrite())
    device.addHIFunction(cDBfg())
    device.addHIFunction(cABRT())
    device.addHIFunction(cGaid())
    device.addHIFunction(cGAID())
    device.addHIFunction(cHRST())
    device.addHIFunction(cCRST())
    device.addHIFunction(cGSkC())
    device.addHIFunction(cGSrC())
    device.addHIFunction(cSSrC())
    device.addHIFunction(cSRDO())
    device.addHIFunction(cSWSk())
    device.addHIFunction(cSWSr())
    device.addHIFunction(cSWDF())
    device.addHIFunction(cSWUF())
    device.addHIFunction(cSWVC())
    device.addHIFunction(cSRDY())
    device.addHIFunction(cAMEn())
    device.addHIFunction(cAMEx())
    device.addHIFunction(cANEG())
    device.addHIFunction(cAMDs())
    device.addHIFunction(cGPie())
    device.addHIFunction(cGPoe())
    device.addHIFunction(cGPsh())
    device.addHIFunction(cGPsl())
    device.addHIFunction(cVDMs())
    device.addHIFunction(cADCs())

    device.configureDerivedFields()
    oneAceDeviceList.append(device)




ACE_register_definition_metadata_json_delimiter{
    "virtual device list of dict": [], 
    "firmware filename": "recovery\\tps65982_evm_flash_image.bin", 
    "device list of dict": [
        {
            "show": 1, 
            "name": "Device 1", 
            "addr": 0
        }, 
        {
            "show": 0, 
            "name": "Config Set 2", 
            "addr": 1
        }
    ], 
    "configuration values": "{\"meta\": {\"project\": 1, \"version\": 1}, \"data\": {\"every_ace\": [{\"register\": 6, \"data\": [7, 2, 0, 0, 0, 0, 0, 0]}], \"header\": {\"usb_if_xid\": 0, \"unlock_code\": \"CST1\", \"customer_version\": 0, \"protection_flags\": 250}, \"bin_table\": [], \"strings\": [{\"is_ascii\": true, \"is_valid\": true, \"string\": \"12.34.56\"}, {\"is_ascii\": true, \"is_valid\": true, \"string\": \"TPS65982\"}, {\"is_ascii\": true, \"is_valid\": true, \"string\": \"Texas Instruments\"}, {\"is_ascii\": true, \"is_valid\": true, \"string\": \"http://www.ti.com/product/TPS65982\"}, {\"is_ascii\": true, \"is_valid\": true, \"string\": \"Thunderbolt Mode Entry Error\"}, {\"is_ascii\": true, \"is_valid\": true, \"string\": \"HTTP://help.vesa.org/dp-usb-type-c\"}], \"selected_ace\": [{\"rights\": 0, \"register\": 6, \"data\": [186, 220, 0, 0, 205, 171, 0, 0], \"offset\": 0, \"address\": [255, 255, 255, 255]}, {\"rights\": 0, \"register\": 22, \"data\": [8, 0, 0, 2, 0, 0, 0, 0], \"offset\": 0, \"address\": [255, 255, 255, 255]}, {\"rights\": 0, \"register\": 23, \"data\": [8, 0, 0, 2, 0, 0, 0, 0], \"offset\": 0, \"address\": [255, 255, 255, 255]}, {\"rights\": 0, \"register\": 40, \"data\": [10, 195, 255, 32, 247, 8, 21, 106, 216, 32, 157, 5, 6, 0, 0, 20, 20, 120], \"offset\": 0, \"address\": [255, 255, 255, 255]}, {\"rights\": 0, \"register\": 41, \"data\": [52, 52, 0, 49, 7], \"offset\": 0, \"address\": [255, 255, 255, 255]}, {\"rights\": 0, \"register\": 50, \"data\": [0, 252, 0, 0, 144, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [255, 255, 255, 255]}, {\"rights\": 0, \"register\": 51, \"data\": [2, 90, 144, 1, 4, 90, 32, 3, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 105, 1, 64, 44, 105, 1, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [255, 255, 255, 255]}, {\"rights\": 0, \"register\": 55, \"data\": [111, 1, 61, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [255, 255, 255, 255]}, {\"rights\": 0, \"register\": 56, \"data\": [135, 128, 1, 0, 1, 255, 1, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [255, 255, 255, 255]}, {\"rights\": 0, \"register\": 71, \"data\": [3, 81, 4, 0, 196, 81, 4, 0, 0, 16, 0, 52, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [255, 255, 255, 255]}, {\"rights\": 0, \"register\": 81, \"data\": [3, 71, 28, 12, 1, 0, 6], \"offset\": 0, \"address\": [255, 255, 255, 255]}, {\"rights\": 0, \"register\": 82, \"data\": [3, 5, 0, 0, 0, 0, 0, 5], \"offset\": 0, \"address\": [255, 255, 255, 255]}, {\"rights\": 0, \"register\": 92, \"data\": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 3, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [255, 255, 255, 255]}, {\"rights\": 0, \"register\": 93, \"data\": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 129, 0, 0, 130, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], \"offset\": 0, \"address\": [255, 255, 255, 255]}, {\"rights\": 0, \"register\": 94, \"data\": [24, 3, 56, 0], \"offset\": 0, \"address\": [255, 255, 255, 255]}, {\"rights\": 0, \"register\": 112, \"data\": [13, 4], \"offset\": 0, \"address\": [255, 255, 255, 255]}]}}", 
    "devices use same config": true, 
    "debug settings": {
        "adapter": "Aardvark"
    }, 
    "template properties": {
        "Mux Type": "USB3.x and DisplayPort", 
        "Description": "TPS65982 Upstream-Facing Port Only, supports HD3SS460 Mux:\n\nPower and data sink only with no power or data source capabilities. This is a good configuration for simple peripheral devices such as dongles, cell phones or flash drives that require power and expect data to be read from them.\n", 
        "Template Version": "6.1.1", 
        "Port Type": "UFP", 
        "Category Type": "Standard Customer Project", 
        "Device Type": "TPS65982", 
        "Display As": "TPS65982 HD3SS460 UFP", 
        "Question List": [
            {
                "Answer": "TPS65982", 
                "Question": "Which device are you using?"
            }, 
            {
                "Answer": "Standard (Recommended)", 
                "Question": "Which template type do you want to start with?"
            }, 
            {
                "Answer": "None", 
                "Question": "Which Thunderbolt controller is used?"
            }, 
            {
                "Answer": "Upstream Facing Port (UFP) Only", 
                "Question": "What is the port type of the design?"
            }
        ]
    }
}